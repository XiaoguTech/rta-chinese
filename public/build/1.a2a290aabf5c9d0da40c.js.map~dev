{"version":3,"sources":["webpack:///1.a2a290aabf5c9d0da40c.js","webpack:///./public/app/containers/Explore/Explore.tsx","webpack:///./public/vendor/flot/jquery.flot.js","webpack:///./public/vendor/flot/jquery.flot.time.js","webpack:///./public/app/containers/Explore/ElapsedTime.tsx","webpack:///./public/app/containers/Explore/Legend.tsx","webpack:///./public/app/containers/Explore/QueryRows.tsx","webpack:///./public/app/containers/Explore/QueryField.tsx","webpack:///./public/app/containers/Explore/utils/dom.ts","webpack:///./public/app/containers/Explore/slate-plugins/braces.ts","webpack:///./public/app/containers/Explore/slate-plugins/clear.ts","webpack:///./public/app/containers/Explore/slate-plugins/newline.ts","webpack:///./public/app/containers/Explore/slate-plugins/prism/index.tsx","webpack:///./public/app/containers/Explore/slate-plugins/prism/promql.ts","webpack:///./public/app/containers/Explore/slate-plugins/runner.ts","webpack:///./public/app/containers/Explore/utils/debounce.ts","webpack:///./public/app/containers/Explore/utils/prometheus.ts","webpack:///./public/app/containers/Explore/Typeahead.tsx","webpack:///./public/app/containers/Explore/Graph.tsx","webpack:///./public/app/containers/Explore/Table.tsx","webpack:///./public/app/containers/Explore/utils/query.ts"],"names":["webpackJsonp","1661","module","__webpack_exports__","__webpack_require__","Object","defineProperty","value","makeTimeSeriesList","dataList","options","map","seriesData","index","datapoints","alias","target","colorIndex","__WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__","length","color","series","__WEBPACK_IMPORTED_MODULE_3_app_core_time_series2__","unit","range","from","isOutsideRange","parseInitialQueries","initial","JSON","parse","__WEBPACK_IMPORTED_MODULE_10_app_core_utils_location_util__","queries","q","query","e","console","error","d","Explore","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_react_hot_loader__","__WEBPACK_IMPORTED_MODULE_4__ElapsedTime__","__WEBPACK_IMPORTED_MODULE_5__Legend__","__WEBPACK_IMPORTED_MODULE_6__QueryRows__","__WEBPACK_IMPORTED_MODULE_7__Graph__","__WEBPACK_IMPORTED_MODULE_8__Table__","__WEBPACK_IMPORTED_MODULE_9__utils_query__","__extends","this","extendStatics","setPrototypeOf","__proto__","Array","b","p","hasOwnProperty","__","constructor","prototype","create","__assign","assign","t","s","i","arguments","call","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","apply","__generator","body","verb","v","op","f","TypeError","_","y","label","ops","pop","trys","push","g","sent","throw","return","Symbol","iterator","_super","props","_this","handleAddQueryRow","state","nextQueries","slice","concat","key","setState","handleChangeQuery","nextQuery","handleClickGraphButton","showingGraph","handleClickTableButton","showingTable","handleRemoveQueryRow","handleSubmit","_a","runTableQuery","runGraphQuery","request","url","datasource","metadataRequest","initialQueries","routeParams","datasourceError","datasourceLoading","graphResult","latency","loading","requestOptions","tableResult","componentDidMount","testResult","datasourceSrv","get","testDatasource","status","message","now","res","error_1","_b","Date","format","interval","instant","data","tableModel","error_2","render","showingBoth","graphHeight","graphButtonClassName","tableButtonClassName","a","createElement","className","title","time","type","onClick","onAddQueryRow","onChangeQuery","onExecuteQuery","onRemoveQueryRow","id","height","Component","1665","exports","$","make","r","o","add","c","charAt","normalize","scale","toString","join","clamp","min","max","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","str","m","exec","parseFloat","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","jQuery","Canvas","cls","container","element","children","document","direction","position","left","top","appendTo","getContext","window","G_vmlCanvasManager","Error","initElement","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","resize","width","textContainer","text","_textCache","_textSizeCache","flotTextSizeCache","Plot","placeholder","data_","options_","plugins","executeHooks","hook","args","plot","setData","parseData","fillInSeriesOptions","processData","extend","axisNumber","obj","coord","allAxes","grep","xaxes","yaxes","canvasToAxisCoords","pos","axis","used","c2p","undefined","x1","x","y1","axisToCanvasCoords","p2c","getOrCreateAxis","axes","number","xaxis","yaxis","neededColors","maxIndex","sc","colors","colorPool","colorPoolSize","variation","colori","lines","show","zero","fill","updateAxis","datamin","fakeInfinity","datamax","j","k","points","ps","val","topSentry","Number","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","MAX_VALUE","each","hooks","processRawData","required","bars","autoscale","defaultValue","horizontal","pointsize","insertSteps","steps","nullify","isNaN","Infinity","transform","processDatapoints","xmin","ymin","xmax","ymax","delta","align","barWidth","shutdown","redrawTimeout","clearTimeout","eventHolder","unbind","onMouseMove","onMouseLeave","setTransformationHelpers","identity","it","inverseTransform","plotWidth","Math","abs","plotHeight","measureTickLabels","opts","ticks","labelWidth","labelHeight","maxWidth","floor","surface","legacyStyles","layer","font","info","getTextInfo","allocateAxisBoxFirstPhase","lw","lh","isXAxis","tickLength","axisMargin","grid","padding","labelMargin","eventSectionPadding","eventSectionHeight","innermost","outermost","first","found","reserveSpace","plotOffset","bottom","box","right","allocateAxisBoxSecondPhase","adjustLayoutForThingsStickingOut","minMargin","minBorderMargin","radius","lineWidth","margins","ceil","setupGrid","showGrid","margin","processOffset","borderWidth","axisOpts","setRange","processRange","allocatedAxes","snaped","setupTickGeneration","setTicks","snapRangeToTicks","drawAxisLabels","insertLegend","widen","autoscaleMargin","noTicks","sqrt","dec","log","LN10","maxDec","tickDecimals","size","magn","pow","norm","minTickSize","tickSize","scaledDecimals","mode","tickGenerator","prev","start","floorInBase","NaN","tickFormatter","factor","formatted","round","decimal","indexOf","precision","substr","isFunction","alignTicksWithAxis","otherAxis","niceTicks","extraDec","ts","test","toFixed","oticks","changed","draw","clear","drawBackground","ctx","backgroundColor","aboveData","drawGrid","drawSeries","triggerRedrawOverlay","extractRange","ranges","to","tmp","save","translate","fillStyle","getColorOrGradient","fillRect","restore","bw","bc","markings","getAxes","xrange","yrange","xequal","yequal","markingsLineWidth","subPixel","beginPath","strokeStyle","markingsColor","moveTo","lineTo","stroke","xoff","yoff","tickColor","borderColor","strokeRect","tick","halign","valign","removeText","addText","drawSeriesLines","drawSeriesBars","drawSeriesPoints","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","y2","lineJoin","sw","shadowSize","angle","PI","sin","cos","getFillStyle","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","plotPoints","offset","shadow","symbol","arc","closePath","w","drawBar","barLeft","barRight","fillStyleCallback","drawLeft","drawRight","drawTop","drawBottom","filloptions","seriesColor","fillColor","legend","html","find","remove","fragments","entries","rowStarted","lf","labelFormatter","sorted","sort","reverse","ascending","entry","noColumns","labelBoxBorderColor","table","replace","backgroundOpacity","div","prependTo","findNearbyItem","mouseX","mouseY","seriesFilter","maxDistance","mouseActiveRadius","smallestDistance","item","mx","my","maxx","maxy","dx","dy","dist","datapoint","dataIndex","seriesIndex","hoverable","triggerClickHoverEvent","isSelecting","eventname","event","canvasX","pageX","canvasY","pageY","ctrlKey","metaKey","autoHighlight","highlights","h","auto","point","unhighlight","highlight","trigger","interaction","redrawOverlayInterval","drawOverlay","setTimeout","octx","overlay","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","splice","highlightColor","pointRadius","spec","defaultColor","gradient","createLinearGradient","l","co","brightness","opacity","addColorStop","clickable","processOptions","bindEvents","getPlaceholder","getCanvas","getPlotOffset","getData","getXAxes","getYAxes","getOptions","pointOffset","destroy","removeData","empty","classes","init","axisOptions","axisCount","fontSize","fontSizeDefault","fontDefaults","style","variant","weight","family","lineHeight","x2axis","y2axis","coloredAreas","coloredAreasColor","existing","mousemove","bind","click","base","fn","detach","parentNode","removeChild","clearRect","cache","layerKey","getTextLayer","layerCache","hide","styleKey","styleCache","positions","active","rendered","append","font-size","insertAfter","addClass","textStyle","max-width","outerWidth","outerHeight","text-align","version","1668","formatDate","fmt","monthNames","dayNames","strftime","leftPad","pad","escape","hours","getHours","isAM","hours12","getDay","getMonth","getDate","getMinutes","getSeconds","getFullYear","makeUtcWrapper","addProxyMethod","sourceObj","sourceMethod","targetObj","targetMethod","utc","date","dateGenerator","timezone","timezoneJS","setTimezone","setTime","axisName","minSize","specQuarters","specMonths","timeUnitSize","year","setSeconds","setMinutes","setHours","setMonth","setFullYear","setMilliseconds","minute","hour","day","setDate","month","quarter","carry","getTime","end","timeformat","useQuarters","span","suffix","hourCode","twelveHourClock","second","baseSpec","1700","ElapsedTime","elapsed","jetzt","timer","setInterval","componentWillReceiveProps","nextProps","clearInterval","componentWillUnmount","1701","LegendItem","Legend","items","1702","__WEBPACK_IMPORTED_MODULE_1__QueryField__","__rest","getOwnPropertySymbols","QueryRow","edited","handleClickAddButton","handleClickRemoveButton","handlePressEnter","initialQuery","onPressEnter","onQueryChange","QueryRows","handlers","1703","flattenSuggestions","reduce","acc","__WEBPACK_IMPORTED_MODULE_1_react_dom__","__WEBPACK_IMPORTED_MODULE_1_react_dom___default","__WEBPACK_IMPORTED_MODULE_2_slate__","__WEBPACK_IMPORTED_MODULE_3_slate_react__","__WEBPACK_IMPORTED_MODULE_4_slate_plain_serializer__","__WEBPACK_IMPORTED_MODULE_5__utils_dom__","__WEBPACK_IMPORTED_MODULE_6__slate_plugins_braces__","__WEBPACK_IMPORTED_MODULE_7__slate_plugins_clear__","__WEBPACK_IMPORTED_MODULE_8__slate_plugins_newline__","__WEBPACK_IMPORTED_MODULE_9__slate_plugins_prism_index__","__WEBPACK_IMPORTED_MODULE_10__slate_plugins_runner__","__WEBPACK_IMPORTED_MODULE_11__utils_debounce__","__WEBPACK_IMPORTED_MODULE_12__utils_prometheus__","__WEBPACK_IMPORTED_MODULE_13__Typeahead__","EMPTY_METRIC","TYPEAHEAD_DEBOUNCE","getInitialValue","fromJSON","nodes","object","leaves","Portal","node","classList","appendChild","createPortal","QueryField","onChange","requestAnimationFrame","handleTypeahead","onMetricsReceived","metrics","change","insertText","deleteBackward","fetch","serialize","selection","getSelection","anchorNode","wrapperNode","parentElement","editorNode","closest","isBlurred","getRangeAt","textContent","startOffset","prefix_1","suggestionGroups","wrapperClasses","typeaheadContext","metricNode","querySelector","contains","metric","labelKeys","startsWith","labelKeyNode","labelKey","labelValues","fetchMetricLabels","defaultKeys","keys","filter","fetchLabelValues","match","results_1","filteredSuggestions","group","typeaheadPrefix","typeaheadText","suggestions","onKeyDown","menuEl","typeaheadIndex","preventDefault","resetTypeahead","flattenedSuggestions","selected","selectedIndex","suggestion","applyTypeahead","handleBlur","onBlur","resetTimer","handleFocus","onFocus","handleClickMenu","updateMenu","menu","removeAttribute","rect","getBoundingClientRect","scrollY","scrollX","menuRef","el","renderMenu","selectedKeys","selectedItems","onClickItem","groupedItems","handler","fetchMetricNames","componentDidUpdate","nextChar","backward","suffixLength","midWord","forward","deleteForward","focus","pairs","values","e_1","_c","json","onRequestError","e_2","_d","autoCorrect","spellCheck","1704","getPreviousCousin","selector","sibling","previousSibling","getNextCharacter","global","Element","matches","ownerDocument","querySelectorAll","1705","BracesPlugin","isCollapsed","BRACES","move","anchorText","anchorOffset","space","length_1","[","{","(","1706","ClearPlugin","1707","getIndent","trimLeft","indent","NewlinePlugin","shiftKey","startBlock","currentLineText","splitBlock","1708","configurePrismMetricsTokens","__WEBPACK_IMPORTED_MODULE_1_prismjs___default","languages","promql","pattern","RegExp","PrismPlugin","renderMark","mark","TOKEN_MARK","decorateNode","processToken","token","types","content","startText","endText","endOffset","newlines","split","available","remaining","texts","shift","anchorKey","focusKey","focusOffset","marks","decorations","_i","subToken","getTexts","toArray","tstring","grammar","tokens","tokenize","tokens_1","__WEBPACK_IMPORTED_MODULE_1_prismjs__","__WEBPACK_IMPORTED_MODULE_2__promql__","1709","OPERATORS","AGGREGATION_OPERATORS","FUNCTIONS","tokenizer","comment","lookbehind","context-aggregation","inside","label-key","context-labels","label-value","greedy","function","context-range","range-duration","operator","punctuation","1710","RunnerPlugin","1711","debounce","func","wait","timeout","later","1712","processLabels","labels","forEach","rest","__name__","RATE_RANGES","cleanText","1713","scrollIntoView","offsetParent","offsetTop","scrollTop","offsetHeight","TypeaheadItem","getRef","prevProps","isSelected","ref","PureComponent","TypeaheadGroup","Typeahead","1714","time_format","secPerTick","__WEBPACK_IMPORTED_MODULE_0_jquery__","__WEBPACK_IMPORTED_MODULE_0_jquery___default","__WEBPACK_IMPORTED_MODULE_1_react__","__WEBPACK_IMPORTED_MODULE_1_react___default","__WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot__","__WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_time__","FLOT_OPTIONS","linewidth","labelMarginX","Graph","userOptions","getFlotPairs","$el","valueOf","dynamicOptions","1715","EMPTY_TABLE","columns","rows","Table","col","row","1716","buildQueryOptions","targets","expr","generateQueryKey","random","ensureQueries","hasQuery","some"],"mappings":"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","file":"1.a2a290aabf5c9d0da40c.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 1661:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Explore\", function() { return Explore; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_hot_loader__ = __webpack_require__(123);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_hot_loader___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_hot_loader__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__ = __webpack_require__(120);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_time_series2__ = __webpack_require__(172);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ElapsedTime__ = __webpack_require__(1700);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Legend__ = __webpack_require__(1701);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__QueryRows__ = __webpack_require__(1702);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Graph__ = __webpack_require__(1714);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Table__ = __webpack_require__(1715);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_query__ = __webpack_require__(1716);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_app_core_utils_location_util__ = __webpack_require__(171);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction makeTimeSeriesList(dataList, options) {\r\n    return dataList.map(function (seriesData, index) {\r\n        var datapoints = seriesData.datapoints || [];\r\n        var alias = seriesData.target;\r\n        var colorIndex = index % __WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__[\"f\" /* default */].length;\r\n        var color = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__[\"f\" /* default */][colorIndex];\r\n        var series = new __WEBPACK_IMPORTED_MODULE_3_app_core_time_series2__[\"a\" /* default */]({\r\n            datapoints: datapoints,\r\n            alias: alias,\r\n            color: color,\r\n            unit: seriesData.unit,\r\n        });\r\n        if (datapoints && datapoints.length > 0) {\r\n            var last = datapoints[datapoints.length - 1][1];\r\n            var from = options.range.from;\r\n            if (last - from < -10000) {\r\n                series.isOutsideRange = true;\r\n            }\r\n        }\r\n        return series;\r\n    });\r\n}\r\nfunction parseInitialQueries(initial) {\r\n    if (!initial) {\r\n        return [];\r\n    }\r\n    try {\r\n        var parsed = JSON.parse(Object(__WEBPACK_IMPORTED_MODULE_10_app_core_utils_location_util__[\"a\" /* decodePathComponent */])(initial));\r\n        return parsed.queries.map(function (q) { return q.query; });\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        return [];\r\n    }\r\n}\r\n// @observer\r\nvar Explore = /** @class */ (function (_super) {\r\n    __extends(Explore, _super);\r\n    function Explore(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.handleAddQueryRow = function (index) {\r\n            var queries = _this.state.queries;\r\n            var nextQueries = queries.slice(0, index + 1).concat([\r\n                { query: '', key: Object(__WEBPACK_IMPORTED_MODULE_9__utils_query__[\"c\" /* generateQueryKey */])() }\r\n            ], queries.slice(index + 1));\r\n            _this.setState({ queries: nextQueries });\r\n        };\r\n        _this.handleChangeQuery = function (query, index) {\r\n            var queries = _this.state.queries;\r\n            var nextQuery = __assign({}, queries[index], { query: query });\r\n            var nextQueries = queries.slice();\r\n            nextQueries[index] = nextQuery;\r\n            _this.setState({ queries: nextQueries });\r\n        };\r\n        _this.handleClickGraphButton = function () {\r\n            _this.setState(function (state) { return ({ showingGraph: !state.showingGraph }); });\r\n        };\r\n        _this.handleClickTableButton = function () {\r\n            _this.setState(function (state) { return ({ showingTable: !state.showingTable }); });\r\n        };\r\n        _this.handleRemoveQueryRow = function (index) {\r\n            var queries = _this.state.queries;\r\n            if (queries.length <= 1) {\r\n                return;\r\n            }\r\n            var nextQueries = queries.slice(0, index).concat(queries.slice(index + 1));\r\n            _this.setState({ queries: nextQueries }, function () { return _this.handleSubmit(); });\r\n        };\r\n        _this.handleSubmit = function () {\r\n            var _a = _this.state, showingGraph = _a.showingGraph, showingTable = _a.showingTable;\r\n            if (showingTable) {\r\n                _this.runTableQuery();\r\n            }\r\n            if (showingGraph) {\r\n                _this.runGraphQuery();\r\n            }\r\n        };\r\n        _this.request = function (url) {\r\n            var datasource = _this.state.datasource;\r\n            return datasource.metadataRequest(url);\r\n        };\r\n        var initialQueries = parseInitialQueries(props.routeParams.initial);\r\n        _this.state = {\r\n            datasource: null,\r\n            datasourceError: null,\r\n            datasourceLoading: true,\r\n            graphResult: null,\r\n            latency: 0,\r\n            loading: false,\r\n            queries: Object(__WEBPACK_IMPORTED_MODULE_9__utils_query__[\"b\" /* ensureQueries */])(initialQueries),\r\n            requestOptions: null,\r\n            showingGraph: true,\r\n            showingTable: true,\r\n            tableResult: null,\r\n        };\r\n        return _this;\r\n    }\r\n    Explore.prototype.componentDidMount = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var datasource, testResult;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.props.datasourceSrv.get()];\r\n                    case 1:\r\n                        datasource = _a.sent();\r\n                        return [4 /*yield*/, datasource.testDatasource()];\r\n                    case 2:\r\n                        testResult = _a.sent();\r\n                        if (testResult.status === 'success') {\r\n                            this.setState({ datasource: datasource, datasourceError: null, datasourceLoading: false }, function () { return _this.handleSubmit(); });\r\n                        }\r\n                        else {\r\n                            this.setState({ datasource: null, datasourceError: testResult.message, datasourceLoading: false });\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Explore.prototype.runGraphQuery = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, datasource, queries, now, options, res, result, latency, error_1;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.state, datasource = _a.datasource, queries = _a.queries;\r\n                        if (!Object(__WEBPACK_IMPORTED_MODULE_9__utils_query__[\"d\" /* hasQuery */])(queries)) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        this.setState({ latency: 0, loading: true, graphResult: null });\r\n                        now = Date.now();\r\n                        options = Object(__WEBPACK_IMPORTED_MODULE_9__utils_query__[\"a\" /* buildQueryOptions */])({\r\n                            format: 'time_series',\r\n                            interval: datasource.interval,\r\n                            instant: false,\r\n                            now: now,\r\n                            queries: queries.map(function (q) { return q.query; }),\r\n                        });\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, datasource.query(options)];\r\n                    case 2:\r\n                        res = _b.sent();\r\n                        result = makeTimeSeriesList(res.data, options);\r\n                        latency = Date.now() - now;\r\n                        this.setState({ latency: latency, loading: false, graphResult: result, requestOptions: options });\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        error_1 = _b.sent();\r\n                        console.error(error_1);\r\n                        this.setState({ loading: false, graphResult: error_1 });\r\n                        return [3 /*break*/, 4];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Explore.prototype.runTableQuery = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, datasource, queries, now, options, res, tableModel, latency, error_2;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.state, datasource = _a.datasource, queries = _a.queries;\r\n                        if (!Object(__WEBPACK_IMPORTED_MODULE_9__utils_query__[\"d\" /* hasQuery */])(queries)) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        this.setState({ latency: 0, loading: true, tableResult: null });\r\n                        now = Date.now();\r\n                        options = Object(__WEBPACK_IMPORTED_MODULE_9__utils_query__[\"a\" /* buildQueryOptions */])({\r\n                            format: 'table',\r\n                            interval: datasource.interval,\r\n                            instant: true,\r\n                            now: now,\r\n                            queries: queries.map(function (q) { return q.query; }),\r\n                        });\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, datasource.query(options)];\r\n                    case 2:\r\n                        res = _b.sent();\r\n                        tableModel = res.data[0];\r\n                        latency = Date.now() - now;\r\n                        this.setState({ latency: latency, loading: false, tableResult: tableModel, requestOptions: options });\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        error_2 = _b.sent();\r\n                        console.error(error_2);\r\n                        this.setState({ loading: false, tableResult: null });\r\n                        return [3 /*break*/, 4];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Explore.prototype.render = function () {\r\n        var _a = this.state, datasource = _a.datasource, datasourceError = _a.datasourceError, datasourceLoading = _a.datasourceLoading, graphResult = _a.graphResult, latency = _a.latency, loading = _a.loading, queries = _a.queries, requestOptions = _a.requestOptions, showingGraph = _a.showingGraph, showingTable = _a.showingTable, tableResult = _a.tableResult;\r\n        var showingBoth = showingGraph && showingTable;\r\n        var graphHeight = showingBoth ? '200px' : null;\r\n        var graphButtonClassName = showingBoth || showingGraph ? 'btn m-r-1' : 'btn btn-inverse m-r-1';\r\n        var tableButtonClassName = showingBoth || showingTable ? 'btn m-r-1' : 'btn btn-inverse m-r-1';\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"explore\" },\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"page-body page-full\" },\r\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"h2\", { className: \"page-sub-heading\" }, \"Explore\"),\r\n                datasourceLoading ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", null, \"Loading datasource...\") : null,\r\n                datasourceError ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { title: datasourceError }, \"Error connecting to datasource.\") : null,\r\n                datasource ? (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"m-r-3\" },\r\n                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"nav m-b-1\" },\r\n                        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"pull-right\" },\r\n                            loading || latency ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__ElapsedTime__[\"a\" /* default */], { time: latency, className: \"\" }) : null,\r\n                            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"button\", { type: \"submit\", className: \"m-l-1 btn btn-primary\", onClick: this.handleSubmit },\r\n                                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"i\", { className: \"fa fa-return\" }),\r\n                                \" Run Query\")),\r\n                        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", null,\r\n                            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"button\", { className: graphButtonClassName, onClick: this.handleClickGraphButton }, \"Graph\"),\r\n                            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"button\", { className: tableButtonClassName, onClick: this.handleClickTableButton }, \"Table\"))),\r\n                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__QueryRows__[\"a\" /* default */], { queries: queries, request: this.request, onAddQueryRow: this.handleAddQueryRow, onChangeQuery: this.handleChangeQuery, onExecuteQuery: this.handleSubmit, onRemoveQueryRow: this.handleRemoveQueryRow }),\r\n                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"main\", { className: \"m-t-2\" },\r\n                        showingGraph ? (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_7__Graph__[\"a\" /* default */], { data: graphResult, id: \"explore-1\", options: requestOptions, height: graphHeight })) : null,\r\n                        showingGraph ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__Legend__[\"a\" /* default */], { data: graphResult }) : null,\r\n                        showingTable ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__Table__[\"a\" /* default */], { data: tableResult, className: \"m-t-3\" }) : null))) : null)));\r\n    };\r\n    return Explore;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_hot_loader__[\"hot\"])(module)(Explore));\r\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(122)(module)))\n\n/***/ }),\n\n/***/ 1665:\n/***/ (function(module, exports) {\n\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t\tthis._textSizeCache = window.flotTextSizeCache = window.flotTextSizeCache || {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text flot-temp-elem'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n      info = styleCache[text] = { element: element, positions: [] };\n\n      var size = this._textSizeCache[text];\n\t\t\tif (size) {\n        info.width = size.width;\n        info.height = size.height;\n\t\t\t} else {\n        info.width = element.outerWidth(true);\n        info.height = element.outerHeight(true);\n        this._textSizeCache[text] = { width: info.width, height: info.height };\n\t\t\t}\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    eventSectionHeight: 0, // space for event section\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            processRange: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n\n                    if (insertSteps && k > 0 && (!nullify || points[k - ps] != null)) {\n                        // copy the point to make room for a middle point\n                        for (m = 0; m < ps; ++m)\n                            points[k + ps + m] = points[k + m];\n\n                        // middle point has same y\n                        points[k + 1] = points[k - ps + 1] || 0;\n\n                        // if series has null values, let's give the last !null value a nice step\n                        if(nullify)\n                        \tpoints[k] = p[0];\n\n                        // we've added a point, better reflect that\n                        k += ps;\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n\n                // grafana\n                if (s.transform === 'negative-Y') {\n                  for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                      val = points[j + 1];\n                      points[j + 1] = -val;\n                  }\n                }\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.find(\".flot-temp-elem\").remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                /// Grafana fix, add +1 to label width\n                labelWidth = Math.max(labelWidth, info.width + 1);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                eventSectionPadding = options.grid.eventSectionHeight,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                // Add space for event section\n                lh += padding;\n                lh += eventSectionPadding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.box.eventSectionPadding = eventSectionPadding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            executeHooks(hooks.processRange, []);\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                var snaped = false;\n                for (var i = 0; i < 2; i++) {\n                    $.each(allocatedAxes, function (_, axis) {\n                        // make the ticks\n                        setupTickGeneration(axis);\n                        setTicks(axis);\n                        snaped = snapRangeToTicks(axis, axis.ticks) || snaped;\n                        // find labelWidth/Height for axis\n                        measureTickLabels(axis);\n                    });\n\n                    if (snaped && hooks.processRange.length > 0) {\n                        executeHooks(hooks.processRange, []);\n                        snaped = false;\n                    } else {\n                        break;\n                    }\n                }\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // Grafana fix: wide Y min and max using increased wideFactor\n                // when all series values are the same\n                var wideFactor = 0.25;\n                var widen = Math.abs(max == 0 ? 1 : max * wideFactor);\n\n                if (opts.min == null) {\n                  min -= widen;\n                }\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null) {\n                  max += widen;\n                }\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n            // grafana addition\n            axis.scaledDecimals = axis.tickDecimals - Math.floor(Math.log(axis.tickSize) / Math.LN10);\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            var changed = false;\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null) {\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                    changed = true;\n                }\n                if (axis.options.max == null && ticks.length > 1) {\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding + box.eventSectionPadding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very\n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be\n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n          if (plot.isSelecting) {\n            return;\n          }\n\n          triggerClickHoverEvent(\"plotclick\", e, function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            // Add ctrlKey and metaKey to event\n            pos.ctrlKey = event.ctrlKey;\n            pos.metaKey = event.metaKey;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n\n\n/***/ }),\n\n/***/ 1668:\n/***/ (function(module, exports) {\n\n/* Pretty handling of time axes.\n\nCopyright (c) 2007-2013 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nSet axis.mode to \"time\" to enable. See the section \"Time series data\" in\nAPI.txt for details.\n\n*/\n\n(function($) {\n\n\tvar options = {\n\t\txaxis: {\n\t\t\ttimezone: null,\t\t// \"browser\" for local to the client or timezone for timezone-js\n\t\t\ttimeformat: null,\t// format string to use\n\t\t\ttwelveHourClock: false,\t// 12 or 24 time in time mode\n\t\t\tmonthNames: null\t// list of names of months\n\t\t}\n\t};\n\n\t// round to nearby lower multiple of base\n\n\tfunction floorInBase(n, base) {\n\t\treturn base * Math.floor(n / base);\n\t}\n\n\t// Returns a string with the date d formatted according to fmt.\n\t// A subset of the Open Group's strftime format is supported.\n\n\tfunction formatDate(d, fmt, monthNames, dayNames) {\n\n\t\tif (typeof d.strftime == \"function\") {\n\t\t\treturn d.strftime(fmt);\n\t\t}\n\n\t\tvar leftPad = function(n, pad) {\n\t\t\tn = \"\" + n;\n\t\t\tpad = \"\" + (pad == null ? \"0\" : pad);\n\t\t\treturn n.length == 1 ? pad + n : n;\n\t\t};\n\n\t\tvar r = [];\n\t\tvar escape = false;\n\t\tvar hours = d.getHours();\n\t\tvar isAM = hours < 12;\n\n\t\tif (monthNames == null) {\n\t\t\tmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\t\t}\n\n\t\tif (dayNames == null) {\n\t\t\tdayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\t\t}\n\n\t\tvar hours12;\n\n\t\tif (hours > 12) {\n\t\t\thours12 = hours - 12;\n\t\t} else if (hours == 0) {\n\t\t\thours12 = 12;\n\t\t} else {\n\t\t\thours12 = hours;\n\t\t}\n\n\t\tfor (var i = 0; i < fmt.length; ++i) {\n\n\t\t\tvar c = fmt.charAt(i);\n\n\t\t\tif (escape) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 'a': c = \"\" + dayNames[d.getDay()]; break;\n\t\t\t\t\tcase 'b': c = \"\" + monthNames[d.getMonth()]; break;\n\t\t\t\t\tcase 'd': c = leftPad(d.getDate(), \"\"); break;\n\t\t\t\t\tcase 'e': c = leftPad(d.getDate(), \" \"); break;\n\t\t\t\t\tcase 'h':\t// For back-compat with 0.7; remove in 1.0\n\t\t\t\t\tcase 'H': c = leftPad(hours); break;\n\t\t\t\t\tcase 'I': c = leftPad(hours12); break;\n\t\t\t\t\tcase 'l': c = leftPad(hours12, \" \"); break;\n\t\t\t\t\tcase 'm': c = leftPad(d.getMonth() + 1, \"\"); break;\n\t\t\t\t\tcase 'M': c = leftPad(d.getMinutes()); break;\n\t\t\t\t\t// quarters not in Open Group's strftime specification\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tc = \"\" + (Math.floor(d.getMonth() / 3) + 1); break;\n\t\t\t\t\tcase 'S': c = leftPad(d.getSeconds()); break;\n\t\t\t\t\tcase 'y': c = leftPad(d.getFullYear() % 100); break;\n\t\t\t\t\tcase 'Y': c = \"\" + d.getFullYear(); break;\n\t\t\t\t\tcase 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\n\t\t\t\t\tcase 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\n\t\t\t\t\tcase 'w': c = \"\" + d.getDay(); break;\n\t\t\t\t}\n\t\t\t\tr.push(c);\n\t\t\t\tescape = false;\n\t\t\t} else {\n\t\t\t\tif (c == \"%\") {\n\t\t\t\t\tescape = true;\n\t\t\t\t} else {\n\t\t\t\t\tr.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn r.join(\"\");\n\t}\n\n\t// To have a consistent view of time-based data independent of which time\n\t// zone the client happens to be in we need a date-like object independent\n\t// of time zones.  This is done through a wrapper that only calls the UTC\n\t// versions of the accessor methods.\n\n\tfunction makeUtcWrapper(d) {\n\n\t\tfunction addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\n\t\t\tsourceObj[sourceMethod] = function() {\n\t\t\t\treturn targetObj[targetMethod].apply(targetObj, arguments);\n\t\t\t};\n\t\t};\n\n\t\tvar utc = {\n\t\t\tdate: d\n\t\t};\n\n\t\t// support strftime, if found\n\n\t\tif (d.strftime != undefined) {\n\t\t\taddProxyMethod(utc, \"strftime\", d, \"strftime\");\n\t\t}\n\n\t\taddProxyMethod(utc, \"getTime\", d, \"getTime\");\n\t\taddProxyMethod(utc, \"setTime\", d, \"setTime\");\n\n\t\tvar props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\n\n\t\tfor (var p = 0; p < props.length; p++) {\n\t\t\taddProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\n\t\t\taddProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\n\t\t}\n\n\t\treturn utc;\n\t};\n\n\t// select time zone strategy.  This returns a date-like object tied to the\n\t// desired timezone\n\n\tfunction dateGenerator(ts, opts) {\n\t\tif (opts.timezone == \"browser\") {\n\t\t\treturn new Date(ts);\n\t\t} else if (!opts.timezone || opts.timezone == \"utc\") {\n\t\t\treturn makeUtcWrapper(new Date(ts));\n\t\t} else if (typeof timezoneJS != \"undefined\" && typeof timezoneJS.Date != \"undefined\") {\n\t\t\tvar d = new timezoneJS.Date();\n\t\t\t// timezone-js is fickle, so be sure to set the time zone before\n\t\t\t// setting the time.\n\t\t\td.setTimezone(opts.timezone);\n\t\t\td.setTime(ts);\n\t\t\treturn d;\n\t\t} else {\n\t\t\treturn makeUtcWrapper(new Date(ts));\n\t\t}\n\t}\n\n\t// map of app. size of time units in milliseconds\n\n\tvar timeUnitSize = {\n\t\t\"second\": 1000,\n\t\t\"minute\": 60 * 1000,\n\t\t\"hour\": 60 * 60 * 1000,\n\t\t\"day\": 24 * 60 * 60 * 1000,\n\t\t\"month\": 30 * 24 * 60 * 60 * 1000,\n\t\t\"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\n\t\t\"year\": 365.2425 * 24 * 60 * 60 * 1000\n\t};\n\n\t// the allowed tick sizes, after 1 year we use\n\t// an integer algorithm\n\n\tvar baseSpec = [\n\t\t[1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\n\t\t[30, \"second\"],\n\t\t[1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\n\t\t[30, \"minute\"],\n\t\t[1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\n\t\t[8, \"hour\"], [12, \"hour\"],\n\t\t[1, \"day\"], [2, \"day\"], [3, \"day\"],\n\t\t[0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\n\t\t[2, \"month\"]\n\t];\n\n\t// we don't know which variant(s) we'll need yet, but generating both is\n\t// cheap\n\n\tvar specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\n\t\t[1, \"year\"]]);\n\tvar specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\n\t\t[1, \"year\"]]);\n\n\tfunction init(plot) {\n\t\tplot.hooks.processOptions.push(function (plot, options) {\n\t\t\t$.each(plot.getAxes(), function(axisName, axis) {\n\n\t\t\t\tvar opts = axis.options;\n\n\t\t\t\tif (opts.mode == \"time\") {\n\t\t\t\t\taxis.tickGenerator = function(axis) {\n\n\t\t\t\t\t\tvar ticks = [];\n\t\t\t\t\t\tvar d = dateGenerator(axis.min, opts);\n\t\t\t\t\t\tvar minSize = 0;\n\n\t\t\t\t\t\t// make quarter use a possibility if quarters are\n\t\t\t\t\t\t// mentioned in either of these options\n\n\t\t\t\t\t\tvar spec = (opts.tickSize && opts.tickSize[1] ===\n\t\t\t\t\t\t\t\"quarter\") ||\n\t\t\t\t\t\t\t(opts.minTickSize && opts.minTickSize[1] ===\n\t\t\t\t\t\t\t\"quarter\") ? specQuarters : specMonths;\n\n\t\t\t\t\t\tif (opts.minTickSize != null) {\n\t\t\t\t\t\t\tif (typeof opts.tickSize == \"number\") {\n\t\t\t\t\t\t\t\tminSize = opts.tickSize;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tminSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0; i < spec.length - 1; ++i) {\n\t\t\t\t\t\t\tif (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]\n\t\t\t\t\t\t\t\t\t\t\t  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\n\t\t\t\t\t\t\t\t&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = spec[i][0];\n\t\t\t\t\t\tvar unit = spec[i][1];\n\n\t\t\t\t\t\t// special-case the possibility of several years\n\n\t\t\t\t\t\tif (unit == \"year\") {\n\n\t\t\t\t\t\t\t// if given a minTickSize in years, just use it,\n\t\t\t\t\t\t\t// ensuring that it's an integer\n\n\t\t\t\t\t\t\tif (opts.minTickSize != null && opts.minTickSize[1] == \"year\") {\n\t\t\t\t\t\t\t\tsize = Math.floor(opts.minTickSize[0]);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\n\t\t\t\t\t\t\t\tvar norm = (axis.delta / timeUnitSize.year) / magn;\n\n\t\t\t\t\t\t\t\tif (norm < 1.5) {\n\t\t\t\t\t\t\t\t\tsize = 1;\n\t\t\t\t\t\t\t\t} else if (norm < 3) {\n\t\t\t\t\t\t\t\t\tsize = 2;\n\t\t\t\t\t\t\t\t} else if (norm < 7.5) {\n\t\t\t\t\t\t\t\t\tsize = 5;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsize = 10;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsize *= magn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// minimum size for years is 1\n\n\t\t\t\t\t\t\tif (size < 1) {\n\t\t\t\t\t\t\t\tsize = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taxis.tickSize = opts.tickSize || [size, unit];\n\t\t\t\t\t\tvar tickSize = axis.tickSize[0];\n\t\t\t\t\t\tunit = axis.tickSize[1];\n\n\t\t\t\t\t\tvar step = tickSize * timeUnitSize[unit];\n\n\t\t\t\t\t\tif (unit == \"second\") {\n\t\t\t\t\t\t\td.setSeconds(floorInBase(d.getSeconds(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"minute\") {\n\t\t\t\t\t\t\td.setMinutes(floorInBase(d.getMinutes(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"hour\") {\n\t\t\t\t\t\t\td.setHours(floorInBase(d.getHours(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"month\") {\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"quarter\") {\n\t\t\t\t\t\t\td.setMonth(3 * floorInBase(d.getMonth() / 3,\n\t\t\t\t\t\t\t\ttickSize));\n\t\t\t\t\t\t} else if (unit == \"year\") {\n\t\t\t\t\t\t\td.setFullYear(floorInBase(d.getFullYear(), tickSize));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// reset smaller components\n\n\t\t\t\t\t\td.setMilliseconds(0);\n\n\t\t\t\t\t\tif (step >= timeUnitSize.minute) {\n\t\t\t\t\t\t\td.setSeconds(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.hour) {\n\t\t\t\t\t\t\td.setMinutes(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.day) {\n\t\t\t\t\t\t\td.setHours(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.day * 4) {\n\t\t\t\t\t\t\td.setDate(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.month * 2) {\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), 3));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.quarter * 2) {\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), 6));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.year) {\n\t\t\t\t\t\t\td.setMonth(0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar carry = 0;\n\t\t\t\t\t\tvar v = Number.NaN;\n\t\t\t\t\t\tvar prev;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tprev = v;\n\t\t\t\t\t\t\tv = d.getTime();\n\t\t\t\t\t\t\tticks.push(v);\n\n\t\t\t\t\t\t\tif (unit == \"month\" || unit == \"quarter\") {\n\t\t\t\t\t\t\t\tif (tickSize < 1) {\n\n\t\t\t\t\t\t\t\t\t// a bit complicated - we'll divide the\n\t\t\t\t\t\t\t\t\t// month/quarter up but we need to take\n\t\t\t\t\t\t\t\t\t// care of fractions so we don't end up in\n\t\t\t\t\t\t\t\t\t// the middle of a day\n\n\t\t\t\t\t\t\t\t\td.setDate(1);\n\t\t\t\t\t\t\t\t\tvar start = d.getTime();\n\t\t\t\t\t\t\t\t\td.setMonth(d.getMonth() +\n\t\t\t\t\t\t\t\t\t\t(unit == \"quarter\" ? 3 : 1));\n\t\t\t\t\t\t\t\t\tvar end = d.getTime();\n\t\t\t\t\t\t\t\t\td.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\n\t\t\t\t\t\t\t\t\tcarry = d.getHours();\n\t\t\t\t\t\t\t\t\td.setHours(0);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\td.setMonth(d.getMonth() +\n\t\t\t\t\t\t\t\t\t\ttickSize * (unit == \"quarter\" ? 3 : 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (unit == \"year\") {\n\t\t\t\t\t\t\t\td.setFullYear(d.getFullYear() + tickSize);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\td.setTime(v + step);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (v < axis.max && v != prev);\n\n\t\t\t\t\t\treturn ticks;\n\t\t\t\t\t};\n\n\t\t\t\t\taxis.tickFormatter = function (v, axis) {\n\n\t\t\t\t\t\tvar d = dateGenerator(v, axis.options);\n\n\t\t\t\t\t\t// first check global format\n\n\t\t\t\t\t\tif (opts.timeformat != null) {\n\t\t\t\t\t\t\treturn formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly use quarters if quarters are mentioned in\n\t\t\t\t\t\t// any of these places\n\n\t\t\t\t\t\tvar useQuarters = (axis.options.tickSize &&\n\t\t\t\t\t\t\t\taxis.options.tickSize[1] == \"quarter\") ||\n\t\t\t\t\t\t\t(axis.options.minTickSize &&\n\t\t\t\t\t\t\t\taxis.options.minTickSize[1] == \"quarter\");\n\n\t\t\t\t\t\tvar t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\n\t\t\t\t\t\tvar span = axis.max - axis.min;\n\t\t\t\t\t\tvar suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\n\t\t\t\t\t\tvar hourCode = (opts.twelveHourClock) ? \"%I\" : \"%H\";\n\t\t\t\t\t\tvar fmt;\n\n\t\t\t\t\t\tif (t < timeUnitSize.minute) {\n\t\t\t\t\t\t\tfmt = hourCode + \":%M:%S\" + suffix;\n\t\t\t\t\t\t} else if (t < timeUnitSize.day) {\n\t\t\t\t\t\t\tif (span < 2 * timeUnitSize.day) {\n\t\t\t\t\t\t\t\tfmt = hourCode + \":%M\" + suffix;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfmt = \"%b %d \" + hourCode + \":%M\" + suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (t < timeUnitSize.month) {\n\t\t\t\t\t\t\tfmt = \"%b %d\";\n\t\t\t\t\t\t} else if ((useQuarters && t < timeUnitSize.quarter) ||\n\t\t\t\t\t\t\t(!useQuarters && t < timeUnitSize.year)) {\n\t\t\t\t\t\t\tif (span < timeUnitSize.year) {\n\t\t\t\t\t\t\t\tfmt = \"%b\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfmt = \"%b %Y\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (useQuarters && t < timeUnitSize.year) {\n\t\t\t\t\t\t\tif (span < timeUnitSize.year) {\n\t\t\t\t\t\t\t\tfmt = \"Q%q\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfmt = \"Q%q %Y\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfmt = \"%Y\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\n\n\t\t\t\t\t\treturn rt;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t$.plot.plugins.push({\n\t\tinit: init,\n\t\toptions: options,\n\t\tname: 'time',\n\t\tversion: '1.0'\n\t});\n\n\t// Time-axis support used to be in Flot core, which exposed the\n\t// formatDate function on the plot object.  Various plugins depend\n\t// on the function, so we need to re-expose it here.\n\n\t$.plot.formatDate = formatDate;\n\n})(jQuery);\n\n\n/***/ }),\n\n/***/ 1700:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar INTERVAL = 150;\r\nvar ElapsedTime = /** @class */ (function (_super) {\r\n    __extends(ElapsedTime, _super);\r\n    function ElapsedTime() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.state = {\r\n            elapsed: 0,\r\n        };\r\n        _this.tick = function () {\r\n            var jetzt = Date.now();\r\n            var elapsed = jetzt - _this.offset;\r\n            _this.setState({ elapsed: elapsed });\r\n        };\r\n        return _this;\r\n    }\r\n    ElapsedTime.prototype.start = function () {\r\n        this.offset = Date.now();\r\n        this.timer = window.setInterval(this.tick, INTERVAL);\r\n    };\r\n    ElapsedTime.prototype.componentWillReceiveProps = function (nextProps) {\r\n        if (nextProps.time) {\r\n            clearInterval(this.timer);\r\n        }\r\n        else if (this.props.time) {\r\n            this.start();\r\n        }\r\n    };\r\n    ElapsedTime.prototype.componentDidMount = function () {\r\n        this.start();\r\n    };\r\n    ElapsedTime.prototype.componentWillUnmount = function () {\r\n        clearInterval(this.timer);\r\n    };\r\n    ElapsedTime.prototype.render = function () {\r\n        var elapsed = this.state.elapsed;\r\n        var _a = this.props, className = _a.className, time = _a.time;\r\n        var value = (time || elapsed) / 1000;\r\n        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"span\", { className: className },\r\n            value.toFixed(1),\r\n            \"s\");\r\n    };\r\n    return ElapsedTime;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (ElapsedTime);\r\n\n\n/***/ }),\n\n/***/ 1701:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar LegendItem = function (_a) {\r\n    var series = _a.series;\r\n    return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"graph-legend-series\" },\r\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"graph-legend-icon\" },\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"i\", { className: \"fa fa-minus pointer\", style: { color: series.color } })),\r\n        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"a\", { className: \"graph-legend-alias pointer\" }, series.alias)));\r\n};\r\nvar Legend = /** @class */ (function (_super) {\r\n    __extends(Legend, _super);\r\n    function Legend() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Legend.prototype.render = function () {\r\n        var _a = this.props, _b = _a.className, className = _b === void 0 ? '' : _b, data = _a.data;\r\n        var items = data || [];\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: className + \" graph-legend ps\" }, items.map(function (series) { return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(LegendItem, { key: series.id, series: series }); })));\r\n    };\r\n    return Legend;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Legend);\r\n\n\n/***/ }),\n\n/***/ 1702:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__QueryField__ = __webpack_require__(1703);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\n\r\n\r\nvar QueryRow = /** @class */ (function (_super) {\r\n    __extends(QueryRow, _super);\r\n    function QueryRow(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.handleChangeQuery = function (value) {\r\n            var _a = _this.props, index = _a.index, onChangeQuery = _a.onChangeQuery;\r\n            var query = _this.state.query;\r\n            var edited = query !== value;\r\n            _this.setState({ edited: edited, query: value });\r\n            if (onChangeQuery) {\r\n                onChangeQuery(value, index);\r\n            }\r\n        };\r\n        _this.handleClickAddButton = function () {\r\n            var _a = _this.props, index = _a.index, onAddQueryRow = _a.onAddQueryRow;\r\n            if (onAddQueryRow) {\r\n                onAddQueryRow(index);\r\n            }\r\n        };\r\n        _this.handleClickRemoveButton = function () {\r\n            var _a = _this.props, index = _a.index, onRemoveQueryRow = _a.onRemoveQueryRow;\r\n            if (onRemoveQueryRow) {\r\n                onRemoveQueryRow(index);\r\n            }\r\n        };\r\n        _this.handlePressEnter = function () {\r\n            var onExecuteQuery = _this.props.onExecuteQuery;\r\n            if (onExecuteQuery) {\r\n                onExecuteQuery();\r\n            }\r\n        };\r\n        _this.state = {\r\n            edited: false,\r\n            query: props.query || '',\r\n        };\r\n        return _this;\r\n    }\r\n    QueryRow.prototype.render = function () {\r\n        var request = this.props.request;\r\n        var _a = this.state, edited = _a.edited, query = _a.query;\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"query-row\" },\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"query-row-tools\" },\r\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"button\", { className: \"btn btn-small btn-inverse\", onClick: this.handleClickAddButton },\r\n                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"i\", { className: \"fa fa-plus\" })),\r\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"button\", { className: \"btn btn-small btn-inverse\", onClick: this.handleClickRemoveButton },\r\n                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"i\", { className: \"fa fa-minus\" }))),\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"query-field-wrapper\" },\r\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__QueryField__[\"a\" /* default */], { initialQuery: edited ? null : query, onPressEnter: this.handlePressEnter, onQueryChange: this.handleChangeQuery, request: request }))));\r\n    };\r\n    return QueryRow;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]));\r\nvar QueryRows = /** @class */ (function (_super) {\r\n    __extends(QueryRows, _super);\r\n    function QueryRows() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    QueryRows.prototype.render = function () {\r\n        var _a = this.props, _b = _a.className, className = _b === void 0 ? '' : _b, queries = _a.queries, handlers = __rest(_a, [\"className\", \"queries\"]);\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: className }, queries.map(function (q, index) { return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(QueryRow, __assign({ key: q.key, index: index, query: q.query }, handlers)); })));\r\n    };\r\n    return QueryRows;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (QueryRows);\r\n\n\n/***/ }),\n\n/***/ 1703:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_slate__ = __webpack_require__(99);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_slate_react__ = __webpack_require__(603);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_slate_plain_serializer__ = __webpack_require__(276);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_dom__ = __webpack_require__(1704);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__slate_plugins_braces__ = __webpack_require__(1705);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__slate_plugins_clear__ = __webpack_require__(1706);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__slate_plugins_newline__ = __webpack_require__(1707);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__slate_plugins_prism_index__ = __webpack_require__(1708);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__slate_plugins_runner__ = __webpack_require__(1710);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_debounce__ = __webpack_require__(1711);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__utils_prometheus__ = __webpack_require__(1712);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__Typeahead__ = __webpack_require__(1713);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n// dom also includes Element polyfills\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar EMPTY_METRIC = '';\r\nvar TYPEAHEAD_DEBOUNCE = 300;\r\nfunction flattenSuggestions(s) {\r\n    return s ? s.reduce(function (acc, g) { return acc.concat(g.items); }, []) : [];\r\n}\r\nvar getInitialValue = function (query) {\r\n    return __WEBPACK_IMPORTED_MODULE_2_slate__[\"Value\"].fromJSON({\r\n        document: {\r\n            nodes: [\r\n                {\r\n                    object: 'block',\r\n                    type: 'paragraph',\r\n                    nodes: [\r\n                        {\r\n                            object: 'text',\r\n                            leaves: [\r\n                                {\r\n                                    text: query,\r\n                                },\r\n                            ],\r\n                        },\r\n                    ],\r\n                },\r\n            ],\r\n        },\r\n    });\r\n};\r\nvar Portal = /** @class */ (function (_super) {\r\n    __extends(Portal, _super);\r\n    function Portal(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.node = document.createElement('div');\r\n        _this.node.classList.add(\"query-field-portal-\" + props.index);\r\n        document.body.appendChild(_this.node);\r\n        return _this;\r\n    }\r\n    Portal.prototype.componentWillUnmount = function () {\r\n        document.body.removeChild(this.node);\r\n    };\r\n    Portal.prototype.render = function () {\r\n        return __WEBPACK_IMPORTED_MODULE_1_react_dom___default.a.createPortal(this.props.children, this.node);\r\n    };\r\n    return Portal;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));\r\nvar QueryField = /** @class */ (function (_super) {\r\n    __extends(QueryField, _super);\r\n    function QueryField(props, context) {\r\n        var _this = _super.call(this, props, context) || this;\r\n        _this.onChange = function (_a) {\r\n            var value = _a.value;\r\n            var changed = value.document !== _this.state.value.document;\r\n            _this.setState({ value: value }, function () {\r\n                if (changed) {\r\n                    _this.handleChangeQuery();\r\n                }\r\n            });\r\n            window.requestAnimationFrame(_this.handleTypeahead);\r\n        };\r\n        _this.onMetricsReceived = function () {\r\n            if (!_this.state.metrics) {\r\n                return;\r\n            }\r\n            Object(__WEBPACK_IMPORTED_MODULE_9__slate_plugins_prism_index__[\"a\" /* configurePrismMetricsTokens */])(_this.state.metrics);\r\n            // Trigger re-render\r\n            window.requestAnimationFrame(function () {\r\n                // Bogus edit to trigger highlighting\r\n                var change = _this.state.value\r\n                    .change()\r\n                    .insertText(' ')\r\n                    .deleteBackward(1);\r\n                _this.onChange(change);\r\n            });\r\n        };\r\n        _this.request = function (url) {\r\n            if (_this.props.request) {\r\n                return _this.props.request(url);\r\n            }\r\n            return fetch(url);\r\n        };\r\n        _this.handleChangeQuery = function () {\r\n            // Send text change to parent\r\n            var onQueryChange = _this.props.onQueryChange;\r\n            if (onQueryChange) {\r\n                onQueryChange(__WEBPACK_IMPORTED_MODULE_4_slate_plain_serializer__[\"default\"].serialize(_this.state.value));\r\n            }\r\n        };\r\n        _this.handleTypeahead = Object(__WEBPACK_IMPORTED_MODULE_11__utils_debounce__[\"a\" /* default */])(function () {\r\n            var selection = window.getSelection();\r\n            if (selection.anchorNode) {\r\n                var wrapperNode = selection.anchorNode.parentElement;\r\n                var editorNode = wrapperNode.closest('.query-field');\r\n                if (!editorNode || _this.state.value.isBlurred) {\r\n                    // Not inside this editor\r\n                    return;\r\n                }\r\n                var range = selection.getRangeAt(0);\r\n                var text = selection.anchorNode.textContent;\r\n                var offset = range.startOffset;\r\n                var prefix_1 = Object(__WEBPACK_IMPORTED_MODULE_12__utils_prometheus__[\"b\" /* cleanText */])(text.substr(0, offset));\r\n                // Determine candidates by context\r\n                var suggestionGroups = [];\r\n                var wrapperClasses = wrapperNode.classList;\r\n                var typeaheadContext = null;\r\n                // Take first metric as lucky guess\r\n                var metricNode = editorNode.querySelector('.metric');\r\n                if (wrapperClasses.contains('context-range')) {\r\n                    // Rate ranges\r\n                    typeaheadContext = 'context-range';\r\n                    suggestionGroups.push({\r\n                        label: 'Range vector',\r\n                        items: __WEBPACK_IMPORTED_MODULE_12__utils_prometheus__[\"a\" /* RATE_RANGES */].slice(),\r\n                    });\r\n                }\r\n                else if (wrapperClasses.contains('context-labels') && metricNode) {\r\n                    var metric = metricNode.textContent;\r\n                    var labelKeys = _this.state.labelKeys[metric];\r\n                    if (labelKeys) {\r\n                        if ((text && text.startsWith('=')) || wrapperClasses.contains('attr-value')) {\r\n                            // Label values\r\n                            var labelKeyNode = Object(__WEBPACK_IMPORTED_MODULE_5__utils_dom__[\"b\" /* getPreviousCousin */])(wrapperNode, '.attr-name');\r\n                            if (labelKeyNode) {\r\n                                var labelKey = labelKeyNode.textContent;\r\n                                var labelValues = _this.state.labelValues[metric][labelKey];\r\n                                typeaheadContext = 'context-label-values';\r\n                                suggestionGroups.push({\r\n                                    label: 'Label values',\r\n                                    items: labelValues,\r\n                                });\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Label keys\r\n                            typeaheadContext = 'context-labels';\r\n                            suggestionGroups.push({ label: 'Labels', items: labelKeys });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _this.fetchMetricLabels(metric);\r\n                    }\r\n                }\r\n                else if (wrapperClasses.contains('context-labels') && !metricNode) {\r\n                    // Empty name queries\r\n                    var defaultKeys = ['job', 'instance'];\r\n                    // Munge all keys that we have seen together\r\n                    var labelKeys = Object.keys(_this.state.labelKeys).reduce(function (acc, metric) {\r\n                        return acc.concat(_this.state.labelKeys[metric].filter(function (key) { return acc.indexOf(key) === -1; }));\r\n                    }, defaultKeys);\r\n                    if ((text && text.startsWith('=')) || wrapperClasses.contains('attr-value')) {\r\n                        // Label values\r\n                        var labelKeyNode = Object(__WEBPACK_IMPORTED_MODULE_5__utils_dom__[\"b\" /* getPreviousCousin */])(wrapperNode, '.attr-name');\r\n                        if (labelKeyNode) {\r\n                            var labelKey = labelKeyNode.textContent;\r\n                            if (_this.state.labelValues[EMPTY_METRIC]) {\r\n                                var labelValues = _this.state.labelValues[EMPTY_METRIC][labelKey];\r\n                                typeaheadContext = 'context-label-values';\r\n                                suggestionGroups.push({\r\n                                    label: 'Label values',\r\n                                    items: labelValues,\r\n                                });\r\n                            }\r\n                            else {\r\n                                // Can only query label values for now (API to query keys is under development)\r\n                                _this.fetchLabelValues(labelKey);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Label keys\r\n                        typeaheadContext = 'context-labels';\r\n                        suggestionGroups.push({ label: 'Labels', items: labelKeys });\r\n                    }\r\n                }\r\n                else if (metricNode && wrapperClasses.contains('context-aggregation')) {\r\n                    typeaheadContext = 'context-aggregation';\r\n                    var metric = metricNode.textContent;\r\n                    var labelKeys = _this.state.labelKeys[metric];\r\n                    if (labelKeys) {\r\n                        suggestionGroups.push({ label: 'Labels', items: labelKeys });\r\n                    }\r\n                    else {\r\n                        _this.fetchMetricLabels(metric);\r\n                    }\r\n                }\r\n                else if ((_this.state.metrics && ((prefix_1 && !wrapperClasses.contains('token')) || text.match(/[+\\-*/^%]/))) ||\r\n                    wrapperClasses.contains('context-function')) {\r\n                    // Need prefix for metrics\r\n                    typeaheadContext = 'context-metrics';\r\n                    suggestionGroups.push({\r\n                        label: 'Metrics',\r\n                        items: _this.state.metrics,\r\n                    });\r\n                }\r\n                var results_1 = 0;\r\n                var filteredSuggestions = suggestionGroups.map(function (group) {\r\n                    if (group.items) {\r\n                        group.items = group.items.filter(function (c) { return c.length !== prefix_1.length && c.indexOf(prefix_1) > -1; });\r\n                        results_1 += group.items.length;\r\n                    }\r\n                    return group;\r\n                });\r\n                console.log('handleTypeahead', selection.anchorNode, wrapperClasses, text, offset, prefix_1, typeaheadContext);\r\n                _this.setState({\r\n                    typeaheadPrefix: prefix_1,\r\n                    typeaheadContext: typeaheadContext,\r\n                    typeaheadText: text,\r\n                    suggestions: results_1 > 0 ? filteredSuggestions : [],\r\n                });\r\n            }\r\n        }, TYPEAHEAD_DEBOUNCE);\r\n        _this.onKeyDown = function (event, change) {\r\n            if (_this.menuEl) {\r\n                var _a = _this.state, typeaheadIndex = _a.typeaheadIndex, suggestions = _a.suggestions;\r\n                switch (event.key) {\r\n                    case 'Escape': {\r\n                        if (_this.menuEl) {\r\n                            event.preventDefault();\r\n                            _this.resetTypeahead();\r\n                            return true;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case 'Tab': {\r\n                        // Dont blur input\r\n                        event.preventDefault();\r\n                        if (!suggestions || suggestions.length === 0) {\r\n                            return undefined;\r\n                        }\r\n                        // Get the currently selected suggestion\r\n                        var flattenedSuggestions = flattenSuggestions(suggestions);\r\n                        var selected = Math.abs(typeaheadIndex);\r\n                        var selectedIndex = selected % flattenedSuggestions.length || 0;\r\n                        var suggestion = flattenedSuggestions[selectedIndex];\r\n                        _this.applyTypeahead(change, suggestion);\r\n                        return true;\r\n                    }\r\n                    case 'ArrowDown': {\r\n                        // Select next suggestion\r\n                        event.preventDefault();\r\n                        _this.setState({ typeaheadIndex: typeaheadIndex + 1 });\r\n                        break;\r\n                    }\r\n                    case 'ArrowUp': {\r\n                        // Select previous suggestion\r\n                        event.preventDefault();\r\n                        _this.setState({ typeaheadIndex: Math.max(0, typeaheadIndex - 1) });\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // console.log('default key', event.key, event.which, event.charCode, event.locale, data.key);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return undefined;\r\n        };\r\n        _this.resetTypeahead = function () {\r\n            _this.setState({\r\n                suggestions: [],\r\n                typeaheadIndex: 0,\r\n                typeaheadPrefix: '',\r\n                typeaheadContext: null,\r\n            });\r\n        };\r\n        _this.handleBlur = function () {\r\n            var onBlur = _this.props.onBlur;\r\n            // If we dont wait here, menu clicks wont work because the menu\r\n            // will be gone.\r\n            _this.resetTimer = setTimeout(_this.resetTypeahead, 100);\r\n            if (onBlur) {\r\n                onBlur();\r\n            }\r\n        };\r\n        _this.handleFocus = function () {\r\n            var onFocus = _this.props.onFocus;\r\n            if (onFocus) {\r\n                onFocus();\r\n            }\r\n        };\r\n        _this.handleClickMenu = function (item) {\r\n            // Manually triggering change\r\n            var change = _this.applyTypeahead(_this.state.value.change(), item);\r\n            _this.onChange(change);\r\n        };\r\n        _this.updateMenu = function () {\r\n            var suggestions = _this.state.suggestions;\r\n            var menu = _this.menuEl;\r\n            var selection = window.getSelection();\r\n            var node = selection.anchorNode;\r\n            // No menu, nothing to do\r\n            if (!menu) {\r\n                return;\r\n            }\r\n            // No suggestions or blur, remove menu\r\n            var hasSuggesstions = suggestions && suggestions.length > 0;\r\n            if (!hasSuggesstions) {\r\n                menu.removeAttribute('style');\r\n                return;\r\n            }\r\n            // Align menu overlay to editor node\r\n            if (node) {\r\n                var rect = node.parentElement.getBoundingClientRect();\r\n                menu.style.opacity = 1;\r\n                menu.style.top = rect.top + window.scrollY + rect.height + 4 + \"px\";\r\n                menu.style.left = rect.left + window.scrollX - 2 + \"px\";\r\n            }\r\n        };\r\n        _this.menuRef = function (el) {\r\n            _this.menuEl = el;\r\n        };\r\n        _this.renderMenu = function () {\r\n            var suggestions = _this.state.suggestions;\r\n            var hasSuggesstions = suggestions && suggestions.length > 0;\r\n            if (!hasSuggesstions) {\r\n                return null;\r\n            }\r\n            // Guard selectedIndex to be within the length of the suggestions\r\n            var selectedIndex = Math.max(_this.state.typeaheadIndex, 0);\r\n            var flattenedSuggestions = flattenSuggestions(suggestions);\r\n            selectedIndex = selectedIndex % flattenedSuggestions.length || 0;\r\n            var selectedKeys = flattenedSuggestions.length > 0 ? [flattenedSuggestions[selectedIndex]] : [];\r\n            // Create typeahead in DOM root so we can later position it absolutely\r\n            return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Portal, null,\r\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_13__Typeahead__[\"a\" /* default */], { menuRef: _this.menuRef, selectedItems: selectedKeys, onClickItem: _this.handleClickMenu, groupedItems: suggestions })));\r\n        };\r\n        _this.plugins = [\r\n            Object(__WEBPACK_IMPORTED_MODULE_6__slate_plugins_braces__[\"a\" /* default */])(),\r\n            Object(__WEBPACK_IMPORTED_MODULE_7__slate_plugins_clear__[\"a\" /* default */])(),\r\n            Object(__WEBPACK_IMPORTED_MODULE_10__slate_plugins_runner__[\"a\" /* default */])({ handler: props.onPressEnter }),\r\n            Object(__WEBPACK_IMPORTED_MODULE_8__slate_plugins_newline__[\"a\" /* default */])(),\r\n            Object(__WEBPACK_IMPORTED_MODULE_9__slate_plugins_prism_index__[\"b\" /* default */])(),\r\n        ];\r\n        _this.state = {\r\n            labelKeys: {},\r\n            labelValues: {},\r\n            metrics: props.metrics || [],\r\n            suggestions: [],\r\n            typeaheadIndex: 0,\r\n            typeaheadPrefix: '',\r\n            value: getInitialValue(props.initialQuery || ''),\r\n        };\r\n        return _this;\r\n    }\r\n    QueryField.prototype.componentDidMount = function () {\r\n        this.updateMenu();\r\n        if (this.props.metrics === undefined) {\r\n            this.fetchMetricNames();\r\n        }\r\n    };\r\n    QueryField.prototype.componentWillUnmount = function () {\r\n        clearTimeout(this.resetTimer);\r\n    };\r\n    QueryField.prototype.componentDidUpdate = function () {\r\n        this.updateMenu();\r\n    };\r\n    QueryField.prototype.componentWillReceiveProps = function (nextProps) {\r\n        if (nextProps.metrics && nextProps.metrics !== this.props.metrics) {\r\n            this.setState({ metrics: nextProps.metrics }, this.onMetricsReceived);\r\n        }\r\n        // initialQuery is null in case the user typed\r\n        if (nextProps.initialQuery !== null && nextProps.initialQuery !== this.props.initialQuery) {\r\n            this.setState({ value: getInitialValue(nextProps.initialQuery) });\r\n        }\r\n    };\r\n    QueryField.prototype.applyTypeahead = function (change, suggestion) {\r\n        var _a = this.state, typeaheadPrefix = _a.typeaheadPrefix, typeaheadContext = _a.typeaheadContext, typeaheadText = _a.typeaheadText;\r\n        // Modify suggestion based on context\r\n        switch (typeaheadContext) {\r\n            case 'context-labels': {\r\n                var nextChar = Object(__WEBPACK_IMPORTED_MODULE_5__utils_dom__[\"a\" /* getNextCharacter */])();\r\n                if (!nextChar || nextChar === '}' || nextChar === ',') {\r\n                    suggestion += '=';\r\n                }\r\n                break;\r\n            }\r\n            case 'context-label-values': {\r\n                // Always add quotes and remove existing ones instead\r\n                if (!(typeaheadText.startsWith('=\"') || typeaheadText.startsWith('\"'))) {\r\n                    suggestion = \"\\\"\" + suggestion;\r\n                }\r\n                if (Object(__WEBPACK_IMPORTED_MODULE_5__utils_dom__[\"a\" /* getNextCharacter */])() !== '\"') {\r\n                    suggestion = suggestion + \"\\\"\";\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n        }\r\n        this.resetTypeahead();\r\n        // Remove the current, incomplete text and replace it with the selected suggestion\r\n        var backward = typeaheadPrefix.length;\r\n        var text = Object(__WEBPACK_IMPORTED_MODULE_12__utils_prometheus__[\"b\" /* cleanText */])(typeaheadText);\r\n        var suffixLength = text.length - typeaheadPrefix.length;\r\n        var offset = typeaheadText.indexOf(typeaheadPrefix);\r\n        var midWord = typeaheadPrefix && ((suffixLength > 0 && offset > -1) || suggestion === typeaheadText);\r\n        var forward = midWord ? suffixLength + offset : 0;\r\n        return (change\r\n            // TODO this line breaks if cursor was moved left and length is longer than whole prefix\r\n            .deleteBackward(backward)\r\n            .deleteForward(forward)\r\n            .insertText(suggestion)\r\n            .focus());\r\n    };\r\n    QueryField.prototype.fetchLabelValues = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, res, body, pairs, values, labelValues, e_1, _a, _b;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        url = \"/api/v1/label/\" + key + \"/values\";\r\n                        _c.label = 1;\r\n                    case 1:\r\n                        _c.trys.push([1, 4, , 5]);\r\n                        return [4 /*yield*/, this.request(url)];\r\n                    case 2:\r\n                        res = _c.sent();\r\n                        return [4 /*yield*/, (res.data || res.json())];\r\n                    case 3:\r\n                        body = _c.sent();\r\n                        pairs = this.state.labelValues[EMPTY_METRIC];\r\n                        values = __assign({}, pairs, (_a = {}, _a[key] = body.data, _a));\r\n                        labelValues = __assign({}, this.state.labelValues, (_b = {}, _b[EMPTY_METRIC] = values, _b));\r\n                        this.setState({ labelValues: labelValues }, this.handleTypeahead);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_1 = _c.sent();\r\n                        if (this.props.onRequestError) {\r\n                            this.props.onRequestError(e_1);\r\n                        }\r\n                        else {\r\n                            console.error(e_1);\r\n                        }\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    QueryField.prototype.fetchMetricLabels = function (name) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, res, body, _a, keys, values, labelKeys, labelValues, e_2, _b, _c;\r\n            return __generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        url = \"/api/v1/series?match[]=\" + name;\r\n                        _d.label = 1;\r\n                    case 1:\r\n                        _d.trys.push([1, 4, , 5]);\r\n                        return [4 /*yield*/, this.request(url)];\r\n                    case 2:\r\n                        res = _d.sent();\r\n                        return [4 /*yield*/, (res.data || res.json())];\r\n                    case 3:\r\n                        body = _d.sent();\r\n                        _a = Object(__WEBPACK_IMPORTED_MODULE_12__utils_prometheus__[\"c\" /* processLabels */])(body.data), keys = _a.keys, values = _a.values;\r\n                        labelKeys = __assign({}, this.state.labelKeys, (_b = {}, _b[name] = keys, _b));\r\n                        labelValues = __assign({}, this.state.labelValues, (_c = {}, _c[name] = values, _c));\r\n                        this.setState({ labelKeys: labelKeys, labelValues: labelValues }, this.handleTypeahead);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_2 = _d.sent();\r\n                        if (this.props.onRequestError) {\r\n                            this.props.onRequestError(e_2);\r\n                        }\r\n                        else {\r\n                            console.error(e_2);\r\n                        }\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    QueryField.prototype.fetchMetricNames = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, res, body, error_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = '/api/v1/label/__name__/values';\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 4, , 5]);\r\n                        return [4 /*yield*/, this.request(url)];\r\n                    case 2:\r\n                        res = _a.sent();\r\n                        return [4 /*yield*/, (res.data || res.json())];\r\n                    case 3:\r\n                        body = _a.sent();\r\n                        this.setState({ metrics: body.data }, this.onMetricsReceived);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        error_1 = _a.sent();\r\n                        if (this.props.onRequestError) {\r\n                            this.props.onRequestError(error_1);\r\n                        }\r\n                        else {\r\n                            console.error(error_1);\r\n                        }\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    QueryField.prototype.render = function () {\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"query-field\" },\r\n            this.renderMenu(),\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_slate_react__[\"Editor\"], { autoCorrect: false, onBlur: this.handleBlur, onKeyDown: this.onKeyDown, onChange: this.onChange, onFocus: this.handleFocus, placeholder: this.props.placeholder, plugins: this.plugins, spellCheck: false, value: this.state.value })));\r\n    };\r\n    return QueryField;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (QueryField);\r\n\n\n/***/ }),\n\n/***/ 1704:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = getPreviousCousin;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getNextCharacter;\n// Node.closest() polyfill\r\nif ('Element' in window && !Element.prototype.closest) {\r\n    Element.prototype.closest = function (s) {\r\n        var matches = (this.document || this.ownerDocument).querySelectorAll(s);\r\n        var el = this;\r\n        var i;\r\n        // eslint-disable-next-line\r\n        do {\r\n            i = matches.length;\r\n            // eslint-disable-next-line\r\n            while (--i >= 0 && matches.item(i) !== el) { }\r\n        } while (i < 0 && (el = el.parentElement));\r\n        return el;\r\n    };\r\n}\r\nfunction getPreviousCousin(node, selector) {\r\n    var sibling = node.parentElement.previousSibling;\r\n    var el;\r\n    while (sibling) {\r\n        el = sibling.querySelector(selector);\r\n        if (el) {\r\n            return el;\r\n        }\r\n        sibling = sibling.previousSibling;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getNextCharacter(global) {\r\n    if (global === void 0) { global = window; }\r\n    var selection = global.getSelection();\r\n    if (!selection.anchorNode) {\r\n        return null;\r\n    }\r\n    var range = selection.getRangeAt(0);\r\n    var text = selection.anchorNode.textContent;\r\n    var offset = range.startOffset;\r\n    return text.substr(offset, 1);\r\n}\r\n\n\n/***/ }),\n\n/***/ 1705:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = BracesPlugin;\nvar BRACES = {\r\n    '[': ']',\r\n    '{': '}',\r\n    '(': ')',\r\n};\r\nfunction BracesPlugin() {\r\n    return {\r\n        onKeyDown: function (event, change) {\r\n            var value = change.value;\r\n            if (!value.isCollapsed) {\r\n                return undefined;\r\n            }\r\n            switch (event.key) {\r\n                case '{':\r\n                case '[': {\r\n                    event.preventDefault();\r\n                    // Insert matching braces\r\n                    change\r\n                        .insertText(\"\" + event.key + BRACES[event.key])\r\n                        .move(-1)\r\n                        .focus();\r\n                    return true;\r\n                }\r\n                case '(': {\r\n                    event.preventDefault();\r\n                    var text = value.anchorText.text;\r\n                    var offset = value.anchorOffset;\r\n                    var space = text.indexOf(' ', offset);\r\n                    var length_1 = space > 0 ? space : text.length;\r\n                    var forward = length_1 - offset;\r\n                    // Insert matching braces\r\n                    change\r\n                        .insertText(event.key)\r\n                        .move(forward)\r\n                        .insertText(BRACES[event.key])\r\n                        .move(-1 - forward)\r\n                        .focus();\r\n                    return true;\r\n                }\r\n                default: {\r\n                    break;\r\n                }\r\n            }\r\n            return undefined;\r\n        },\r\n    };\r\n}\r\n\n\n/***/ }),\n\n/***/ 1706:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ClearPlugin;\n// Clears the rest of the line after the caret\r\nfunction ClearPlugin() {\r\n    return {\r\n        onKeyDown: function (event, change) {\r\n            var value = change.value;\r\n            if (!value.isCollapsed) {\r\n                return undefined;\r\n            }\r\n            if (event.key === 'k' && event.ctrlKey) {\r\n                event.preventDefault();\r\n                var text = value.anchorText.text;\r\n                var offset = value.anchorOffset;\r\n                var length_1 = text.length;\r\n                var forward = length_1 - offset;\r\n                change.deleteForward(forward);\r\n                return true;\r\n            }\r\n            return undefined;\r\n        },\r\n    };\r\n}\r\n\n\n/***/ }),\n\n/***/ 1707:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = NewlinePlugin;\nfunction getIndent(text) {\r\n    var offset = text.length - text.trimLeft().length;\r\n    if (offset) {\r\n        var indent = text[0];\r\n        while (--offset) {\r\n            indent += text[0];\r\n        }\r\n        return indent;\r\n    }\r\n    return '';\r\n}\r\nfunction NewlinePlugin() {\r\n    return {\r\n        onKeyDown: function (event, change) {\r\n            var value = change.value;\r\n            if (!value.isCollapsed) {\r\n                return undefined;\r\n            }\r\n            if (event.key === 'Enter' && event.shiftKey) {\r\n                event.preventDefault();\r\n                var startBlock = value.startBlock;\r\n                var currentLineText = startBlock.text;\r\n                var indent = getIndent(currentLineText);\r\n                return change\r\n                    .splitBlock()\r\n                    .insertText(indent)\r\n                    .focus();\r\n            }\r\n        },\r\n    };\r\n}\r\n\n\n/***/ }),\n\n/***/ 1708:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = configurePrismMetricsTokens;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = PrismPlugin;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prismjs__ = __webpack_require__(604);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prismjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prismjs__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__promql__ = __webpack_require__(1709);\n\r\n\r\n\r\n__WEBPACK_IMPORTED_MODULE_1_prismjs___default.a.languages.promql = __WEBPACK_IMPORTED_MODULE_2__promql__[\"a\" /* default */];\r\nvar TOKEN_MARK = 'prism-token';\r\nfunction configurePrismMetricsTokens(metrics) {\r\n    __WEBPACK_IMPORTED_MODULE_1_prismjs___default.a.languages.promql.metric = {\r\n        alias: 'variable',\r\n        pattern: new RegExp(\"(?:^|\\\\s)(\" + metrics.join('|') + \")(?:$|\\\\s)\"),\r\n    };\r\n}\r\n/**\r\n * Code-highlighting plugin based on Prism and\r\n * https://github.com/ianstormtaylor/slate/blob/master/examples/code-highlighting/index.js\r\n *\r\n * (Adapted to handle nested grammar definitions.)\r\n */\r\nfunction PrismPlugin() {\r\n    return {\r\n        /**\r\n         * Render a Slate mark with appropiate CSS class names\r\n         *\r\n         * @param {Object} props\r\n         * @return {Element}\r\n         */\r\n        renderMark: function (props) {\r\n            var children = props.children, mark = props.mark;\r\n            // Only apply spans to marks identified by this plugin\r\n            if (mark.type !== TOKEN_MARK) {\r\n                return undefined;\r\n            }\r\n            var className = \"token \" + mark.data.get('types');\r\n            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"span\", { className: className }, children);\r\n        },\r\n        /**\r\n         * Decorate code blocks with Prism.js highlighting.\r\n         *\r\n         * @param {Node} node\r\n         * @return {Array}\r\n         */\r\n        decorateNode: function (node) {\r\n            if (node.type !== 'paragraph') {\r\n                return [];\r\n            }\r\n            var texts = node.getTexts().toArray();\r\n            var tstring = texts.map(function (t) { return t.text; }).join('\\n');\r\n            var grammar = __WEBPACK_IMPORTED_MODULE_1_prismjs___default.a.languages.promql;\r\n            var tokens = __WEBPACK_IMPORTED_MODULE_1_prismjs___default.a.tokenize(tstring, grammar);\r\n            var decorations = [];\r\n            var startText = texts.shift();\r\n            var endText = startText;\r\n            var startOffset = 0;\r\n            var endOffset = 0;\r\n            var start = 0;\r\n            function processToken(token, acc) {\r\n                // Accumulate token types down the tree\r\n                var types = (acc || '') + \" \" + (token.type || '') + \" \" + (token.alias || '');\r\n                // Add mark for token node\r\n                if (typeof token === 'string' || typeof token.content === 'string') {\r\n                    startText = endText;\r\n                    startOffset = endOffset;\r\n                    var content = typeof token === 'string' ? token : token.content;\r\n                    var newlines = content.split('\\n').length - 1;\r\n                    var length_1 = content.length - newlines;\r\n                    var end = start + length_1;\r\n                    var available = startText.text.length - startOffset;\r\n                    var remaining = length_1;\r\n                    endOffset = startOffset + remaining;\r\n                    while (available < remaining) {\r\n                        endText = texts.shift();\r\n                        remaining = length_1 - available;\r\n                        available = endText.text.length;\r\n                        endOffset = remaining;\r\n                    }\r\n                    // Inject marks from up the tree (acc) as well\r\n                    if (typeof token !== 'string' || acc) {\r\n                        var range = {\r\n                            anchorKey: startText.key,\r\n                            anchorOffset: startOffset,\r\n                            focusKey: endText.key,\r\n                            focusOffset: endOffset,\r\n                            marks: [{ type: TOKEN_MARK, data: { types: types } }],\r\n                        };\r\n                        decorations.push(range);\r\n                    }\r\n                    start = end;\r\n                }\r\n                else if (token.content && token.content.length) {\r\n                    // Tokens can be nested\r\n                    for (var _i = 0, _a = token.content; _i < _a.length; _i++) {\r\n                        var subToken = _a[_i];\r\n                        processToken(subToken, types);\r\n                    }\r\n                }\r\n            }\r\n            // Process top-level tokens\r\n            for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\r\n                var token = tokens_1[_i];\r\n                processToken(token);\r\n            }\r\n            return decorations;\r\n        },\r\n    };\r\n}\r\n\n\n/***/ }),\n\n/***/ 1709:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export OPERATORS */\n/* unused harmony export FUNCTIONS */\nvar OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];\r\nvar AGGREGATION_OPERATORS = [\r\n    'sum',\r\n    'min',\r\n    'max',\r\n    'avg',\r\n    'stddev',\r\n    'stdvar',\r\n    'count',\r\n    'count_values',\r\n    'bottomk',\r\n    'topk',\r\n    'quantile',\r\n];\r\nvar FUNCTIONS = AGGREGATION_OPERATORS.concat([\r\n    'abs',\r\n    'absent',\r\n    'ceil',\r\n    'changes',\r\n    'clamp_max',\r\n    'clamp_min',\r\n    'count_scalar',\r\n    'day_of_month',\r\n    'day_of_week',\r\n    'days_in_month',\r\n    'delta',\r\n    'deriv',\r\n    'drop_common_labels',\r\n    'exp',\r\n    'floor',\r\n    'histogram_quantile',\r\n    'holt_winters',\r\n    'hour',\r\n    'idelta',\r\n    'increase',\r\n    'irate',\r\n    'label_replace',\r\n    'ln',\r\n    'log2',\r\n    'log10',\r\n    'minute',\r\n    'month',\r\n    'predict_linear',\r\n    'rate',\r\n    'resets',\r\n    'round',\r\n    'scalar',\r\n    'sort',\r\n    'sort_desc',\r\n    'sqrt',\r\n    'time',\r\n    'vector',\r\n    'year',\r\n    'avg_over_time',\r\n    'min_over_time',\r\n    'max_over_time',\r\n    'sum_over_time',\r\n    'count_over_time',\r\n    'quantile_over_time',\r\n    'stddev_over_time',\r\n    'stdvar_over_time',\r\n]);\r\nvar tokenizer = {\r\n    comment: {\r\n        pattern: /(^|[^\\n])#.*/,\r\n        lookbehind: true,\r\n    },\r\n    'context-aggregation': {\r\n        pattern: /((by|without)\\s*)\\([^)]*\\)/,\r\n        lookbehind: true,\r\n        inside: {\r\n            'label-key': {\r\n                pattern: /[^,\\s][^,]*[^,\\s]*/,\r\n                alias: 'attr-name',\r\n            },\r\n        },\r\n    },\r\n    'context-labels': {\r\n        pattern: /\\{[^}]*(?=})/,\r\n        inside: {\r\n            'label-key': {\r\n                pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\r\n                alias: 'attr-name',\r\n            },\r\n            'label-value': {\r\n                pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\r\n                greedy: true,\r\n                alias: 'attr-value',\r\n            },\r\n        },\r\n    },\r\n    function: new RegExp(\"\\\\b(?:\" + FUNCTIONS.join('|') + \")(?=\\\\s*\\\\()\", 'i'),\r\n    'context-range': [\r\n        {\r\n            pattern: /\\[[^\\]]*(?=])/,\r\n            inside: {\r\n                'range-duration': {\r\n                    pattern: /\\b\\d+[smhdwy]\\b/i,\r\n                    alias: 'number',\r\n                },\r\n            },\r\n        },\r\n        {\r\n            pattern: /(offset\\s+)\\w+/,\r\n            lookbehind: true,\r\n            inside: {\r\n                'range-duration': {\r\n                    pattern: /\\b\\d+[smhdwy]\\b/i,\r\n                    alias: 'number',\r\n                },\r\n            },\r\n        },\r\n    ],\r\n    number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\r\n    operator: new RegExp(\"/[-+*/=%^~]|&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\\\b(?:\" + OPERATORS.join('|') + \")\\\\b\", 'i'),\r\n    punctuation: /[{};()`,.]/,\r\n};\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (tokenizer);\r\n\n\n/***/ }),\n\n/***/ 1710:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = RunnerPlugin;\nfunction RunnerPlugin(_a) {\r\n    var handler = _a.handler;\r\n    return {\r\n        onKeyDown: function (event) {\r\n            // Handle enter\r\n            if (handler && event.key === 'Enter' && !event.shiftKey) {\r\n                // Submit on Enter\r\n                event.preventDefault();\r\n                handler(event);\r\n                return true;\r\n            }\r\n            return undefined;\r\n        },\r\n    };\r\n}\r\n\n\n/***/ }),\n\n/***/ 1711:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = debounce;\n// Based on underscore.js debounce()\r\nfunction debounce(func, wait) {\r\n    var timeout;\r\n    return function () {\r\n        var context = this;\r\n        var args = arguments;\r\n        var later = function () {\r\n            timeout = null;\r\n            func.apply(context, args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\r\n\n\n/***/ }),\n\n/***/ 1712:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return RATE_RANGES; });\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = processLabels;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return cleanText; });\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\nvar RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\r\nfunction processLabels(labels) {\r\n    var values = {};\r\n    labels.forEach(function (l) {\r\n        var __name__ = l.__name__, rest = __rest(l, [\"__name__\"]);\r\n        Object.keys(rest).forEach(function (key) {\r\n            if (!values[key]) {\r\n                values[key] = [];\r\n            }\r\n            if (values[key].indexOf(rest[key]) === -1) {\r\n                values[key].push(rest[key]);\r\n            }\r\n        });\r\n    });\r\n    return { values: values, keys: Object.keys(values) };\r\n}\r\n// Strip syntax chars\r\nvar cleanText = function (s) { return s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim(); };\r\n\n\n/***/ }),\n\n/***/ 1713:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\n\r\nfunction scrollIntoView(el) {\r\n    if (!el || !el.offsetParent) {\r\n        return;\r\n    }\r\n    var container = el.offsetParent;\r\n    if (el.offsetTop > container.scrollTop + container.offsetHeight || el.offsetTop < container.scrollTop) {\r\n        container.scrollTop = el.offsetTop - container.offsetTop;\r\n    }\r\n}\r\nvar TypeaheadItem = /** @class */ (function (_super) {\r\n    __extends(TypeaheadItem, _super);\r\n    function TypeaheadItem() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.getRef = function (el) {\r\n            _this.el = el;\r\n        };\r\n        return _this;\r\n    }\r\n    TypeaheadItem.prototype.componentDidUpdate = function (prevProps) {\r\n        if (this.props.isSelected && !prevProps.isSelected) {\r\n            scrollIntoView(this.el);\r\n        }\r\n    };\r\n    TypeaheadItem.prototype.render = function () {\r\n        var _a = this.props, isSelected = _a.isSelected, label = _a.label, onClickItem = _a.onClickItem;\r\n        var className = isSelected ? 'typeahead-item typeahead-item__selected' : 'typeahead-item';\r\n        var onClick = function () { return onClickItem(label); };\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"li\", { ref: this.getRef, className: className, onClick: onClick }, label));\r\n    };\r\n    return TypeaheadItem;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.PureComponent));\r\nvar TypeaheadGroup = /** @class */ (function (_super) {\r\n    __extends(TypeaheadGroup, _super);\r\n    function TypeaheadGroup() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TypeaheadGroup.prototype.render = function () {\r\n        var _a = this.props, items = _a.items, label = _a.label, selected = _a.selected, onClickItem = _a.onClickItem;\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"li\", { className: \"typeahead-group\" },\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", { className: \"typeahead-group__title\" }, label),\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"ul\", { className: \"typeahead-group__list\" }, items.map(function (item) { return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(TypeaheadItem, { key: item, onClickItem: onClickItem, isSelected: selected.indexOf(item) > -1, label: item })); }))));\r\n    };\r\n    return TypeaheadGroup;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.PureComponent));\r\nvar Typeahead = /** @class */ (function (_super) {\r\n    __extends(Typeahead, _super);\r\n    function Typeahead() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Typeahead.prototype.render = function () {\r\n        var _a = this.props, groupedItems = _a.groupedItems, menuRef = _a.menuRef, selectedItems = _a.selectedItems, onClickItem = _a.onClickItem;\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"ul\", { className: \"typeahead\", ref: menuRef }, groupedItems.map(function (g) { return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(TypeaheadGroup, __assign({ key: g.label, onClickItem: onClickItem, selected: selectedItems }, g))); })));\r\n    };\r\n    return Typeahead;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.PureComponent));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Typeahead);\r\n\n\n/***/ }),\n\n/***/ 1714:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot__ = __webpack_require__(1665);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_time__ = __webpack_require__(1668);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_time___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_time__);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\n\r\n\r\n\r\n\r\n// Copied from graph.ts\r\nfunction time_format(ticks, min, max) {\r\n    if (min && max && ticks) {\r\n        var range = max - min;\r\n        var secPerTick = range / ticks / 1000;\r\n        var oneDay = 86400000;\r\n        var oneYear = 31536000000;\r\n        if (secPerTick <= 45) {\r\n            return '%H:%M:%S';\r\n        }\r\n        if (secPerTick <= 7200 || range <= oneDay) {\r\n            return '%H:%M';\r\n        }\r\n        if (secPerTick <= 80000) {\r\n            return '%m/%d %H:%M';\r\n        }\r\n        if (secPerTick <= 2419200 || range <= oneYear) {\r\n            return '%m/%d';\r\n        }\r\n        return '%Y-%m';\r\n    }\r\n    return '%H:%M';\r\n}\r\nvar FLOT_OPTIONS = {\r\n    legend: {\r\n        show: false,\r\n    },\r\n    series: {\r\n        lines: {\r\n            linewidth: 1,\r\n            zero: false,\r\n        },\r\n        shadowSize: 0,\r\n    },\r\n    grid: {\r\n        minBorderMargin: 0,\r\n        markings: [],\r\n        backgroundColor: null,\r\n        borderWidth: 0,\r\n        // hoverable: true,\r\n        clickable: true,\r\n        color: '#a1a1a1',\r\n        margin: { left: 0, right: 0 },\r\n        labelMarginX: 0,\r\n    },\r\n};\r\nvar Graph = /** @class */ (function (_super) {\r\n    __extends(Graph, _super);\r\n    function Graph() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Graph.prototype.componentDidMount = function () {\r\n        this.draw();\r\n    };\r\n    Graph.prototype.componentDidUpdate = function (prevProps) {\r\n        if (prevProps.data !== this.props.data ||\r\n            prevProps.options !== this.props.options ||\r\n            prevProps.height !== this.props.height) {\r\n            this.draw();\r\n        }\r\n    };\r\n    Graph.prototype.draw = function () {\r\n        var _a = this.props, data = _a.data, userOptions = _a.options;\r\n        if (!data) {\r\n            return;\r\n        }\r\n        var series = data.map(function (ts) { return ({\r\n            label: ts.label,\r\n            data: ts.getFlotPairs('null'),\r\n        }); });\r\n        var $el = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(\"#\" + this.props.id);\r\n        var ticks = $el.width() / 100;\r\n        var min = userOptions.range.from.valueOf();\r\n        var max = userOptions.range.to.valueOf();\r\n        var dynamicOptions = {\r\n            xaxis: {\r\n                mode: 'time',\r\n                min: min,\r\n                max: max,\r\n                label: 'Datetime',\r\n                ticks: ticks,\r\n                timeformat: time_format(ticks, min, max),\r\n            },\r\n        };\r\n        var options = __assign({}, FLOT_OPTIONS, dynamicOptions, userOptions);\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.plot($el, series, options);\r\n    };\r\n    Graph.prototype.render = function () {\r\n        var style = {\r\n            height: this.props.height || '400px',\r\n            width: this.props.width || '100%',\r\n        };\r\n        return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(\"div\", { id: this.props.id, style: style });\r\n    };\r\n    return Graph;\r\n}(__WEBPACK_IMPORTED_MODULE_1_react__[\"Component\"]));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Graph);\r\n\n\n/***/ }),\n\n/***/ 1715:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n// import TableModel from 'app/core/table_model';\r\nvar EMPTY_TABLE = {\r\n    columns: [],\r\n    rows: [],\r\n};\r\nvar Table = /** @class */ (function (_super) {\r\n    __extends(Table, _super);\r\n    function Table() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Table.prototype.render = function () {\r\n        var _a = this.props, _b = _a.className, className = _b === void 0 ? '' : _b, data = _a.data;\r\n        var tableModel = data || EMPTY_TABLE;\r\n        return (__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"table\", { className: className + \" filter-table\" },\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"thead\", null,\r\n                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"tr\", null, tableModel.columns.map(function (col) { return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"th\", { key: col.text }, col.text); }))),\r\n            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"tbody\", null, tableModel.rows.map(function (row, i) { return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"tr\", { key: i }, row.map(function (content, j) { return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"td\", { key: j }, content); })); }))));\r\n    };\r\n    return Table;\r\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]));\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Table);\r\n\n\n/***/ }),\n\n/***/ 1716:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = buildQueryOptions;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = generateQueryKey;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = ensureQueries;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = hasQuery;\nfunction buildQueryOptions(_a) {\r\n    var format = _a.format, interval = _a.interval, instant = _a.instant, now = _a.now, queries = _a.queries;\r\n    var to = now;\r\n    var from = to - 1000 * 60 * 60 * 3;\r\n    return {\r\n        interval: interval,\r\n        range: {\r\n            from: from,\r\n            to: to,\r\n        },\r\n        targets: queries.map(function (expr) { return ({\r\n            expr: expr,\r\n            format: format,\r\n            instant: instant,\r\n        }); }),\r\n    };\r\n}\r\nfunction generateQueryKey(index) {\r\n    if (index === void 0) { index = 0; }\r\n    return \"Q-\" + Date.now() + \"-\" + Math.random() + \"-\" + index;\r\n}\r\nfunction ensureQueries(queries) {\r\n    if (queries && typeof queries === 'object' && queries.length > 0 && typeof queries[0] === 'string') {\r\n        return queries.map(function (query, i) { return ({ key: generateQueryKey(i), query: query }); });\r\n    }\r\n    return [{ key: generateQueryKey(), query: '' }];\r\n}\r\nfunction hasQuery(queries) {\r\n    return queries.some(function (q) { return q.query; });\r\n}\r\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 1.a2a290aabf5c9d0da40c.js","import React from 'react';\nimport { hot } from 'react-hot-loader';\nimport colors from 'app/core/utils/colors';\nimport TimeSeries from 'app/core/time_series2';\n\nimport ElapsedTime from './ElapsedTime';\nimport Legend from './Legend';\nimport QueryRows from './QueryRows';\nimport Graph from './Graph';\nimport Table from './Table';\nimport { DatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { buildQueryOptions, ensureQueries, generateQueryKey, hasQuery } from './utils/query';\nimport { decodePathComponent } from 'app/core/utils/location_util';\n\nfunction makeTimeSeriesList(dataList, options) {\n  return dataList.map((seriesData, index) => {\n    const datapoints = seriesData.datapoints || [];\n    const alias = seriesData.target;\n\n    const colorIndex = index % colors.length;\n    const color = colors[colorIndex];\n\n    const series = new TimeSeries({\n      datapoints: datapoints,\n      alias: alias,\n      color: color,\n      unit: seriesData.unit,\n    });\n\n    if (datapoints && datapoints.length > 0) {\n      const last = datapoints[datapoints.length - 1][1];\n      const from = options.range.from;\n      if (last - from < -10000) {\n        series.isOutsideRange = true;\n      }\n    }\n\n    return series;\n  });\n}\n\nfunction parseInitialQueries(initial) {\n  if (!initial) {\n    return [];\n  }\n  try {\n    const parsed = JSON.parse(decodePathComponent(initial));\n    return parsed.queries.map(q => q.query);\n  } catch (e) {\n    console.error(e);\n    return [];\n  }\n}\n\ninterface IExploreState {\n  datasource: any;\n  datasourceError: any;\n  datasourceLoading: any;\n  graphResult: any;\n  latency: number;\n  loading: any;\n  queries: any;\n  requestOptions: any;\n  showingGraph: boolean;\n  showingTable: boolean;\n  tableResult: any;\n}\n\n// @observer\nexport class Explore extends React.Component<any, IExploreState> {\n  datasourceSrv: DatasourceSrv;\n\n  constructor(props) {\n    super(props);\n    const initialQueries = parseInitialQueries(props.routeParams.initial);\n    this.state = {\n      datasource: null,\n      datasourceError: null,\n      datasourceLoading: true,\n      graphResult: null,\n      latency: 0,\n      loading: false,\n      queries: ensureQueries(initialQueries),\n      requestOptions: null,\n      showingGraph: true,\n      showingTable: true,\n      tableResult: null,\n    };\n  }\n\n  async componentDidMount() {\n    const datasource = await this.props.datasourceSrv.get();\n    const testResult = await datasource.testDatasource();\n    if (testResult.status === 'success') {\n      this.setState({ datasource, datasourceError: null, datasourceLoading: false }, () => this.handleSubmit());\n    } else {\n      this.setState({ datasource: null, datasourceError: testResult.message, datasourceLoading: false });\n    }\n  }\n\n  handleAddQueryRow = index => {\n    const { queries } = this.state;\n    const nextQueries = [\n      ...queries.slice(0, index + 1),\n      { query: '', key: generateQueryKey() },\n      ...queries.slice(index + 1),\n    ];\n    this.setState({ queries: nextQueries });\n  };\n\n  handleChangeQuery = (query, index) => {\n    const { queries } = this.state;\n    const nextQuery = {\n      ...queries[index],\n      query,\n    };\n    const nextQueries = [...queries];\n    nextQueries[index] = nextQuery;\n    this.setState({ queries: nextQueries });\n  };\n\n  handleClickGraphButton = () => {\n    this.setState(state => ({ showingGraph: !state.showingGraph }));\n  };\n\n  handleClickTableButton = () => {\n    this.setState(state => ({ showingTable: !state.showingTable }));\n  };\n\n  handleRemoveQueryRow = index => {\n    const { queries } = this.state;\n    if (queries.length <= 1) {\n      return;\n    }\n    const nextQueries = [...queries.slice(0, index), ...queries.slice(index + 1)];\n    this.setState({ queries: nextQueries }, () => this.handleSubmit());\n  };\n\n  handleSubmit = () => {\n    const { showingGraph, showingTable } = this.state;\n    if (showingTable) {\n      this.runTableQuery();\n    }\n    if (showingGraph) {\n      this.runGraphQuery();\n    }\n  };\n\n  async runGraphQuery() {\n    const { datasource, queries } = this.state;\n    if (!hasQuery(queries)) {\n      return;\n    }\n    this.setState({ latency: 0, loading: true, graphResult: null });\n    const now = Date.now();\n    const options = buildQueryOptions({\n      format: 'time_series',\n      interval: datasource.interval,\n      instant: false,\n      now,\n      queries: queries.map(q => q.query),\n    });\n    try {\n      const res = await datasource.query(options);\n      const result = makeTimeSeriesList(res.data, options);\n      const latency = Date.now() - now;\n      this.setState({ latency, loading: false, graphResult: result, requestOptions: options });\n    } catch (error) {\n      console.error(error);\n      this.setState({ loading: false, graphResult: error });\n    }\n  }\n\n  async runTableQuery() {\n    const { datasource, queries } = this.state;\n    if (!hasQuery(queries)) {\n      return;\n    }\n    this.setState({ latency: 0, loading: true, tableResult: null });\n    const now = Date.now();\n    const options = buildQueryOptions({\n      format: 'table',\n      interval: datasource.interval,\n      instant: true,\n      now,\n      queries: queries.map(q => q.query),\n    });\n    try {\n      const res = await datasource.query(options);\n      const tableModel = res.data[0];\n      const latency = Date.now() - now;\n      this.setState({ latency, loading: false, tableResult: tableModel, requestOptions: options });\n    } catch (error) {\n      console.error(error);\n      this.setState({ loading: false, tableResult: null });\n    }\n  }\n\n  request = url => {\n    const { datasource } = this.state;\n    return datasource.metadataRequest(url);\n  };\n\n  render() {\n    const {\n      datasource,\n      datasourceError,\n      datasourceLoading,\n      graphResult,\n      latency,\n      loading,\n      queries,\n      requestOptions,\n      showingGraph,\n      showingTable,\n      tableResult,\n    } = this.state;\n    const showingBoth = showingGraph && showingTable;\n    const graphHeight = showingBoth ? '200px' : null;\n    const graphButtonClassName = showingBoth || showingGraph ? 'btn m-r-1' : 'btn btn-inverse m-r-1';\n    const tableButtonClassName = showingBoth || showingTable ? 'btn m-r-1' : 'btn btn-inverse m-r-1';\n    return (\n      <div className=\"explore\">\n        <div className=\"page-body page-full\">\n          <h2 className=\"page-sub-heading\">Explore</h2>\n          {datasourceLoading ? <div>Loading datasource...</div> : null}\n\n          {datasourceError ? <div title={datasourceError}>Error connecting to datasource.</div> : null}\n\n          {datasource ? (\n            <div className=\"m-r-3\">\n              <div className=\"nav m-b-1\">\n                <div className=\"pull-right\">\n                  {loading || latency ? <ElapsedTime time={latency} className=\"\" /> : null}\n                  <button type=\"submit\" className=\"m-l-1 btn btn-primary\" onClick={this.handleSubmit}>\n                    <i className=\"fa fa-return\" /> Run Query\n                  </button>\n                </div>\n                <div>\n                  <button className={graphButtonClassName} onClick={this.handleClickGraphButton}>\n                    Graph\n                  </button>\n                  <button className={tableButtonClassName} onClick={this.handleClickTableButton}>\n                    Table\n                  </button>\n                </div>\n              </div>\n              <QueryRows\n                queries={queries}\n                request={this.request}\n                onAddQueryRow={this.handleAddQueryRow}\n                onChangeQuery={this.handleChangeQuery}\n                onExecuteQuery={this.handleSubmit}\n                onRemoveQueryRow={this.handleRemoveQueryRow}\n              />\n              <main className=\"m-t-2\">\n                {showingGraph ? (\n                  <Graph data={graphResult} id=\"explore-1\" options={requestOptions} height={graphHeight} />\n                ) : null}\n                {showingGraph ? <Legend data={graphResult} /> : null}\n                {showingTable ? <Table data={tableResult} className=\"m-t-3\" /> : null}\n              </main>\n            </div>\n          ) : null}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default hot(module)(Explore);\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/Explore.tsx","/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t\tthis._textSizeCache = window.flotTextSizeCache = window.flotTextSizeCache || {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text flot-temp-elem'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n      info = styleCache[text] = { element: element, positions: [] };\n\n      var size = this._textSizeCache[text];\n\t\t\tif (size) {\n        info.width = size.width;\n        info.height = size.height;\n\t\t\t} else {\n        info.width = element.outerWidth(true);\n        info.height = element.outerHeight(true);\n        this._textSizeCache[text] = { width: info.width, height: info.height };\n\t\t\t}\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    eventSectionHeight: 0, // space for event section\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            processRange: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n\n                    if (insertSteps && k > 0 && (!nullify || points[k - ps] != null)) {\n                        // copy the point to make room for a middle point\n                        for (m = 0; m < ps; ++m)\n                            points[k + ps + m] = points[k + m];\n\n                        // middle point has same y\n                        points[k + 1] = points[k - ps + 1] || 0;\n\n                        // if series has null values, let's give the last !null value a nice step\n                        if(nullify)\n                        \tpoints[k] = p[0];\n\n                        // we've added a point, better reflect that\n                        k += ps;\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n\n                // grafana\n                if (s.transform === 'negative-Y') {\n                  for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                      val = points[j + 1];\n                      points[j + 1] = -val;\n                  }\n                }\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.find(\".flot-temp-elem\").remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                /// Grafana fix, add +1 to label width\n                labelWidth = Math.max(labelWidth, info.width + 1);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                eventSectionPadding = options.grid.eventSectionHeight,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                // Add space for event section\n                lh += padding;\n                lh += eventSectionPadding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.box.eventSectionPadding = eventSectionPadding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            executeHooks(hooks.processRange, []);\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                var snaped = false;\n                for (var i = 0; i < 2; i++) {\n                    $.each(allocatedAxes, function (_, axis) {\n                        // make the ticks\n                        setupTickGeneration(axis);\n                        setTicks(axis);\n                        snaped = snapRangeToTicks(axis, axis.ticks) || snaped;\n                        // find labelWidth/Height for axis\n                        measureTickLabels(axis);\n                    });\n\n                    if (snaped && hooks.processRange.length > 0) {\n                        executeHooks(hooks.processRange, []);\n                        snaped = false;\n                    } else {\n                        break;\n                    }\n                }\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // Grafana fix: wide Y min and max using increased wideFactor\n                // when all series values are the same\n                var wideFactor = 0.25;\n                var widen = Math.abs(max == 0 ? 1 : max * wideFactor);\n\n                if (opts.min == null) {\n                  min -= widen;\n                }\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null) {\n                  max += widen;\n                }\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n            // grafana addition\n            axis.scaledDecimals = axis.tickDecimals - Math.floor(Math.log(axis.tickSize) / Math.LN10);\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            var changed = false;\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null) {\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                    changed = true;\n                }\n                if (axis.options.max == null && ticks.length > 1) {\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding + box.eventSectionPadding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very\n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be\n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n          if (plot.isSelecting) {\n            return;\n          }\n\n          triggerClickHoverEvent(\"plotclick\", e, function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            // Add ctrlKey and metaKey to event\n            pos.ctrlKey = event.ctrlKey;\n            pos.metaKey = event.metaKey;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/vendor/flot/jquery.flot.js\n// module id = 1665\n// module chunks = 0 1","/* Pretty handling of time axes.\n\nCopyright (c) 2007-2013 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nSet axis.mode to \"time\" to enable. See the section \"Time series data\" in\nAPI.txt for details.\n\n*/\n\n(function($) {\n\n\tvar options = {\n\t\txaxis: {\n\t\t\ttimezone: null,\t\t// \"browser\" for local to the client or timezone for timezone-js\n\t\t\ttimeformat: null,\t// format string to use\n\t\t\ttwelveHourClock: false,\t// 12 or 24 time in time mode\n\t\t\tmonthNames: null\t// list of names of months\n\t\t}\n\t};\n\n\t// round to nearby lower multiple of base\n\n\tfunction floorInBase(n, base) {\n\t\treturn base * Math.floor(n / base);\n\t}\n\n\t// Returns a string with the date d formatted according to fmt.\n\t// A subset of the Open Group's strftime format is supported.\n\n\tfunction formatDate(d, fmt, monthNames, dayNames) {\n\n\t\tif (typeof d.strftime == \"function\") {\n\t\t\treturn d.strftime(fmt);\n\t\t}\n\n\t\tvar leftPad = function(n, pad) {\n\t\t\tn = \"\" + n;\n\t\t\tpad = \"\" + (pad == null ? \"0\" : pad);\n\t\t\treturn n.length == 1 ? pad + n : n;\n\t\t};\n\n\t\tvar r = [];\n\t\tvar escape = false;\n\t\tvar hours = d.getHours();\n\t\tvar isAM = hours < 12;\n\n\t\tif (monthNames == null) {\n\t\t\tmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\t\t}\n\n\t\tif (dayNames == null) {\n\t\t\tdayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\t\t}\n\n\t\tvar hours12;\n\n\t\tif (hours > 12) {\n\t\t\thours12 = hours - 12;\n\t\t} else if (hours == 0) {\n\t\t\thours12 = 12;\n\t\t} else {\n\t\t\thours12 = hours;\n\t\t}\n\n\t\tfor (var i = 0; i < fmt.length; ++i) {\n\n\t\t\tvar c = fmt.charAt(i);\n\n\t\t\tif (escape) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 'a': c = \"\" + dayNames[d.getDay()]; break;\n\t\t\t\t\tcase 'b': c = \"\" + monthNames[d.getMonth()]; break;\n\t\t\t\t\tcase 'd': c = leftPad(d.getDate(), \"\"); break;\n\t\t\t\t\tcase 'e': c = leftPad(d.getDate(), \" \"); break;\n\t\t\t\t\tcase 'h':\t// For back-compat with 0.7; remove in 1.0\n\t\t\t\t\tcase 'H': c = leftPad(hours); break;\n\t\t\t\t\tcase 'I': c = leftPad(hours12); break;\n\t\t\t\t\tcase 'l': c = leftPad(hours12, \" \"); break;\n\t\t\t\t\tcase 'm': c = leftPad(d.getMonth() + 1, \"\"); break;\n\t\t\t\t\tcase 'M': c = leftPad(d.getMinutes()); break;\n\t\t\t\t\t// quarters not in Open Group's strftime specification\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tc = \"\" + (Math.floor(d.getMonth() / 3) + 1); break;\n\t\t\t\t\tcase 'S': c = leftPad(d.getSeconds()); break;\n\t\t\t\t\tcase 'y': c = leftPad(d.getFullYear() % 100); break;\n\t\t\t\t\tcase 'Y': c = \"\" + d.getFullYear(); break;\n\t\t\t\t\tcase 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\n\t\t\t\t\tcase 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\n\t\t\t\t\tcase 'w': c = \"\" + d.getDay(); break;\n\t\t\t\t}\n\t\t\t\tr.push(c);\n\t\t\t\tescape = false;\n\t\t\t} else {\n\t\t\t\tif (c == \"%\") {\n\t\t\t\t\tescape = true;\n\t\t\t\t} else {\n\t\t\t\t\tr.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn r.join(\"\");\n\t}\n\n\t// To have a consistent view of time-based data independent of which time\n\t// zone the client happens to be in we need a date-like object independent\n\t// of time zones.  This is done through a wrapper that only calls the UTC\n\t// versions of the accessor methods.\n\n\tfunction makeUtcWrapper(d) {\n\n\t\tfunction addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\n\t\t\tsourceObj[sourceMethod] = function() {\n\t\t\t\treturn targetObj[targetMethod].apply(targetObj, arguments);\n\t\t\t};\n\t\t};\n\n\t\tvar utc = {\n\t\t\tdate: d\n\t\t};\n\n\t\t// support strftime, if found\n\n\t\tif (d.strftime != undefined) {\n\t\t\taddProxyMethod(utc, \"strftime\", d, \"strftime\");\n\t\t}\n\n\t\taddProxyMethod(utc, \"getTime\", d, \"getTime\");\n\t\taddProxyMethod(utc, \"setTime\", d, \"setTime\");\n\n\t\tvar props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\n\n\t\tfor (var p = 0; p < props.length; p++) {\n\t\t\taddProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\n\t\t\taddProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\n\t\t}\n\n\t\treturn utc;\n\t};\n\n\t// select time zone strategy.  This returns a date-like object tied to the\n\t// desired timezone\n\n\tfunction dateGenerator(ts, opts) {\n\t\tif (opts.timezone == \"browser\") {\n\t\t\treturn new Date(ts);\n\t\t} else if (!opts.timezone || opts.timezone == \"utc\") {\n\t\t\treturn makeUtcWrapper(new Date(ts));\n\t\t} else if (typeof timezoneJS != \"undefined\" && typeof timezoneJS.Date != \"undefined\") {\n\t\t\tvar d = new timezoneJS.Date();\n\t\t\t// timezone-js is fickle, so be sure to set the time zone before\n\t\t\t// setting the time.\n\t\t\td.setTimezone(opts.timezone);\n\t\t\td.setTime(ts);\n\t\t\treturn d;\n\t\t} else {\n\t\t\treturn makeUtcWrapper(new Date(ts));\n\t\t}\n\t}\n\n\t// map of app. size of time units in milliseconds\n\n\tvar timeUnitSize = {\n\t\t\"second\": 1000,\n\t\t\"minute\": 60 * 1000,\n\t\t\"hour\": 60 * 60 * 1000,\n\t\t\"day\": 24 * 60 * 60 * 1000,\n\t\t\"month\": 30 * 24 * 60 * 60 * 1000,\n\t\t\"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\n\t\t\"year\": 365.2425 * 24 * 60 * 60 * 1000\n\t};\n\n\t// the allowed tick sizes, after 1 year we use\n\t// an integer algorithm\n\n\tvar baseSpec = [\n\t\t[1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\n\t\t[30, \"second\"],\n\t\t[1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\n\t\t[30, \"minute\"],\n\t\t[1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\n\t\t[8, \"hour\"], [12, \"hour\"],\n\t\t[1, \"day\"], [2, \"day\"], [3, \"day\"],\n\t\t[0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\n\t\t[2, \"month\"]\n\t];\n\n\t// we don't know which variant(s) we'll need yet, but generating both is\n\t// cheap\n\n\tvar specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\n\t\t[1, \"year\"]]);\n\tvar specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\n\t\t[1, \"year\"]]);\n\n\tfunction init(plot) {\n\t\tplot.hooks.processOptions.push(function (plot, options) {\n\t\t\t$.each(plot.getAxes(), function(axisName, axis) {\n\n\t\t\t\tvar opts = axis.options;\n\n\t\t\t\tif (opts.mode == \"time\") {\n\t\t\t\t\taxis.tickGenerator = function(axis) {\n\n\t\t\t\t\t\tvar ticks = [];\n\t\t\t\t\t\tvar d = dateGenerator(axis.min, opts);\n\t\t\t\t\t\tvar minSize = 0;\n\n\t\t\t\t\t\t// make quarter use a possibility if quarters are\n\t\t\t\t\t\t// mentioned in either of these options\n\n\t\t\t\t\t\tvar spec = (opts.tickSize && opts.tickSize[1] ===\n\t\t\t\t\t\t\t\"quarter\") ||\n\t\t\t\t\t\t\t(opts.minTickSize && opts.minTickSize[1] ===\n\t\t\t\t\t\t\t\"quarter\") ? specQuarters : specMonths;\n\n\t\t\t\t\t\tif (opts.minTickSize != null) {\n\t\t\t\t\t\t\tif (typeof opts.tickSize == \"number\") {\n\t\t\t\t\t\t\t\tminSize = opts.tickSize;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tminSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0; i < spec.length - 1; ++i) {\n\t\t\t\t\t\t\tif (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]\n\t\t\t\t\t\t\t\t\t\t\t  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\n\t\t\t\t\t\t\t\t&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = spec[i][0];\n\t\t\t\t\t\tvar unit = spec[i][1];\n\n\t\t\t\t\t\t// special-case the possibility of several years\n\n\t\t\t\t\t\tif (unit == \"year\") {\n\n\t\t\t\t\t\t\t// if given a minTickSize in years, just use it,\n\t\t\t\t\t\t\t// ensuring that it's an integer\n\n\t\t\t\t\t\t\tif (opts.minTickSize != null && opts.minTickSize[1] == \"year\") {\n\t\t\t\t\t\t\t\tsize = Math.floor(opts.minTickSize[0]);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\n\t\t\t\t\t\t\t\tvar norm = (axis.delta / timeUnitSize.year) / magn;\n\n\t\t\t\t\t\t\t\tif (norm < 1.5) {\n\t\t\t\t\t\t\t\t\tsize = 1;\n\t\t\t\t\t\t\t\t} else if (norm < 3) {\n\t\t\t\t\t\t\t\t\tsize = 2;\n\t\t\t\t\t\t\t\t} else if (norm < 7.5) {\n\t\t\t\t\t\t\t\t\tsize = 5;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsize = 10;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsize *= magn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// minimum size for years is 1\n\n\t\t\t\t\t\t\tif (size < 1) {\n\t\t\t\t\t\t\t\tsize = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taxis.tickSize = opts.tickSize || [size, unit];\n\t\t\t\t\t\tvar tickSize = axis.tickSize[0];\n\t\t\t\t\t\tunit = axis.tickSize[1];\n\n\t\t\t\t\t\tvar step = tickSize * timeUnitSize[unit];\n\n\t\t\t\t\t\tif (unit == \"second\") {\n\t\t\t\t\t\t\td.setSeconds(floorInBase(d.getSeconds(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"minute\") {\n\t\t\t\t\t\t\td.setMinutes(floorInBase(d.getMinutes(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"hour\") {\n\t\t\t\t\t\t\td.setHours(floorInBase(d.getHours(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"month\") {\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), tickSize));\n\t\t\t\t\t\t} else if (unit == \"quarter\") {\n\t\t\t\t\t\t\td.setMonth(3 * floorInBase(d.getMonth() / 3,\n\t\t\t\t\t\t\t\ttickSize));\n\t\t\t\t\t\t} else if (unit == \"year\") {\n\t\t\t\t\t\t\td.setFullYear(floorInBase(d.getFullYear(), tickSize));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// reset smaller components\n\n\t\t\t\t\t\td.setMilliseconds(0);\n\n\t\t\t\t\t\tif (step >= timeUnitSize.minute) {\n\t\t\t\t\t\t\td.setSeconds(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.hour) {\n\t\t\t\t\t\t\td.setMinutes(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.day) {\n\t\t\t\t\t\t\td.setHours(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.day * 4) {\n\t\t\t\t\t\t\td.setDate(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.month * 2) {\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), 3));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.quarter * 2) {\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), 6));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step >= timeUnitSize.year) {\n\t\t\t\t\t\t\td.setMonth(0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar carry = 0;\n\t\t\t\t\t\tvar v = Number.NaN;\n\t\t\t\t\t\tvar prev;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tprev = v;\n\t\t\t\t\t\t\tv = d.getTime();\n\t\t\t\t\t\t\tticks.push(v);\n\n\t\t\t\t\t\t\tif (unit == \"month\" || unit == \"quarter\") {\n\t\t\t\t\t\t\t\tif (tickSize < 1) {\n\n\t\t\t\t\t\t\t\t\t// a bit complicated - we'll divide the\n\t\t\t\t\t\t\t\t\t// month/quarter up but we need to take\n\t\t\t\t\t\t\t\t\t// care of fractions so we don't end up in\n\t\t\t\t\t\t\t\t\t// the middle of a day\n\n\t\t\t\t\t\t\t\t\td.setDate(1);\n\t\t\t\t\t\t\t\t\tvar start = d.getTime();\n\t\t\t\t\t\t\t\t\td.setMonth(d.getMonth() +\n\t\t\t\t\t\t\t\t\t\t(unit == \"quarter\" ? 3 : 1));\n\t\t\t\t\t\t\t\t\tvar end = d.getTime();\n\t\t\t\t\t\t\t\t\td.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\n\t\t\t\t\t\t\t\t\tcarry = d.getHours();\n\t\t\t\t\t\t\t\t\td.setHours(0);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\td.setMonth(d.getMonth() +\n\t\t\t\t\t\t\t\t\t\ttickSize * (unit == \"quarter\" ? 3 : 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (unit == \"year\") {\n\t\t\t\t\t\t\t\td.setFullYear(d.getFullYear() + tickSize);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\td.setTime(v + step);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (v < axis.max && v != prev);\n\n\t\t\t\t\t\treturn ticks;\n\t\t\t\t\t};\n\n\t\t\t\t\taxis.tickFormatter = function (v, axis) {\n\n\t\t\t\t\t\tvar d = dateGenerator(v, axis.options);\n\n\t\t\t\t\t\t// first check global format\n\n\t\t\t\t\t\tif (opts.timeformat != null) {\n\t\t\t\t\t\t\treturn formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly use quarters if quarters are mentioned in\n\t\t\t\t\t\t// any of these places\n\n\t\t\t\t\t\tvar useQuarters = (axis.options.tickSize &&\n\t\t\t\t\t\t\t\taxis.options.tickSize[1] == \"quarter\") ||\n\t\t\t\t\t\t\t(axis.options.minTickSize &&\n\t\t\t\t\t\t\t\taxis.options.minTickSize[1] == \"quarter\");\n\n\t\t\t\t\t\tvar t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\n\t\t\t\t\t\tvar span = axis.max - axis.min;\n\t\t\t\t\t\tvar suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\n\t\t\t\t\t\tvar hourCode = (opts.twelveHourClock) ? \"%I\" : \"%H\";\n\t\t\t\t\t\tvar fmt;\n\n\t\t\t\t\t\tif (t < timeUnitSize.minute) {\n\t\t\t\t\t\t\tfmt = hourCode + \":%M:%S\" + suffix;\n\t\t\t\t\t\t} else if (t < timeUnitSize.day) {\n\t\t\t\t\t\t\tif (span < 2 * timeUnitSize.day) {\n\t\t\t\t\t\t\t\tfmt = hourCode + \":%M\" + suffix;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfmt = \"%b %d \" + hourCode + \":%M\" + suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (t < timeUnitSize.month) {\n\t\t\t\t\t\t\tfmt = \"%b %d\";\n\t\t\t\t\t\t} else if ((useQuarters && t < timeUnitSize.quarter) ||\n\t\t\t\t\t\t\t(!useQuarters && t < timeUnitSize.year)) {\n\t\t\t\t\t\t\tif (span < timeUnitSize.year) {\n\t\t\t\t\t\t\t\tfmt = \"%b\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfmt = \"%b %Y\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (useQuarters && t < timeUnitSize.year) {\n\t\t\t\t\t\t\tif (span < timeUnitSize.year) {\n\t\t\t\t\t\t\t\tfmt = \"Q%q\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfmt = \"Q%q %Y\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfmt = \"%Y\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\n\n\t\t\t\t\t\treturn rt;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t$.plot.plugins.push({\n\t\tinit: init,\n\t\toptions: options,\n\t\tname: 'time',\n\t\tversion: '1.0'\n\t});\n\n\t// Time-axis support used to be in Flot core, which exposed the\n\t// formatDate function on the plot object.  Various plugins depend\n\t// on the function, so we need to re-expose it here.\n\n\t$.plot.formatDate = formatDate;\n\n})(jQuery);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/vendor/flot/jquery.flot.time.js\n// module id = 1668\n// module chunks = 0 1","import React, { PureComponent } from 'react';\n\nconst INTERVAL = 150;\n\nexport default class ElapsedTime extends PureComponent<any, any> {\n  offset: number;\n  timer: number;\n\n  state = {\n    elapsed: 0,\n  };\n\n  start() {\n    this.offset = Date.now();\n    this.timer = window.setInterval(this.tick, INTERVAL);\n  }\n\n  tick = () => {\n    const jetzt = Date.now();\n    const elapsed = jetzt - this.offset;\n    this.setState({ elapsed });\n  };\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.time) {\n      clearInterval(this.timer);\n    } else if (this.props.time) {\n      this.start();\n    }\n  }\n\n  componentDidMount() {\n    this.start();\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timer);\n  }\n\n  render() {\n    const { elapsed } = this.state;\n    const { className, time } = this.props;\n    const value = (time || elapsed) / 1000;\n    return <span className={className}>{value.toFixed(1)}s</span>;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/ElapsedTime.tsx","import React, { PureComponent } from 'react';\n\nconst LegendItem = ({ series }) => (\n  <div className=\"graph-legend-series\">\n    <div className=\"graph-legend-icon\">\n      <i className=\"fa fa-minus pointer\" style={{ color: series.color }} />\n    </div>\n    <a className=\"graph-legend-alias pointer\">{series.alias}</a>\n  </div>\n);\n\nexport default class Legend extends PureComponent<any, any> {\n  render() {\n    const { className = '', data } = this.props;\n    const items = data || [];\n    return (\n      <div className={`${className} graph-legend ps`}>\n        {items.map(series => <LegendItem key={series.id} series={series} />)}\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/Legend.tsx","import React, { PureComponent } from 'react';\n\nimport QueryField from './QueryField';\n\nclass QueryRow extends PureComponent<any, any> {\n  constructor(props) {\n    super(props);\n    this.state = {\n      edited: false,\n      query: props.query || '',\n    };\n  }\n\n  handleChangeQuery = value => {\n    const { index, onChangeQuery } = this.props;\n    const { query } = this.state;\n    const edited = query !== value;\n    this.setState({ edited, query: value });\n    if (onChangeQuery) {\n      onChangeQuery(value, index);\n    }\n  };\n\n  handleClickAddButton = () => {\n    const { index, onAddQueryRow } = this.props;\n    if (onAddQueryRow) {\n      onAddQueryRow(index);\n    }\n  };\n\n  handleClickRemoveButton = () => {\n    const { index, onRemoveQueryRow } = this.props;\n    if (onRemoveQueryRow) {\n      onRemoveQueryRow(index);\n    }\n  };\n\n  handlePressEnter = () => {\n    const { onExecuteQuery } = this.props;\n    if (onExecuteQuery) {\n      onExecuteQuery();\n    }\n  };\n\n  render() {\n    const { request } = this.props;\n    const { edited, query } = this.state;\n    return (\n      <div className=\"query-row\">\n        <div className=\"query-row-tools\">\n          <button className=\"btn btn-small btn-inverse\" onClick={this.handleClickAddButton}>\n            <i className=\"fa fa-plus\" />\n          </button>\n          <button className=\"btn btn-small btn-inverse\" onClick={this.handleClickRemoveButton}>\n            <i className=\"fa fa-minus\" />\n          </button>\n        </div>\n        <div className=\"query-field-wrapper\">\n          <QueryField\n            initialQuery={edited ? null : query}\n            onPressEnter={this.handlePressEnter}\n            onQueryChange={this.handleChangeQuery}\n            request={request}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default class QueryRows extends PureComponent<any, any> {\n  render() {\n    const { className = '', queries, ...handlers } = this.props;\n    return (\n      <div className={className}>\n        {queries.map((q, index) => <QueryRow key={q.key} index={index} query={q.query} {...handlers} />)}\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/QueryRows.tsx","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Value } from 'slate';\nimport { Editor } from 'slate-react';\nimport Plain from 'slate-plain-serializer';\n\n// dom also includes Element polyfills\nimport { getNextCharacter, getPreviousCousin } from './utils/dom';\nimport BracesPlugin from './slate-plugins/braces';\nimport ClearPlugin from './slate-plugins/clear';\nimport NewlinePlugin from './slate-plugins/newline';\nimport PluginPrism, { configurePrismMetricsTokens } from './slate-plugins/prism/index';\nimport RunnerPlugin from './slate-plugins/runner';\nimport debounce from './utils/debounce';\nimport { processLabels, RATE_RANGES, cleanText } from './utils/prometheus';\n\nimport Typeahead from './Typeahead';\n\nconst EMPTY_METRIC = '';\nconst TYPEAHEAD_DEBOUNCE = 300;\n\nfunction flattenSuggestions(s) {\n  return s ? s.reduce((acc, g) => acc.concat(g.items), []) : [];\n}\n\nconst getInitialValue = query =>\n  Value.fromJSON({\n    document: {\n      nodes: [\n        {\n          object: 'block',\n          type: 'paragraph',\n          nodes: [\n            {\n              object: 'text',\n              leaves: [\n                {\n                  text: query,\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    },\n  });\n\nclass Portal extends React.Component {\n  node: any;\n  constructor(props) {\n    super(props);\n    this.node = document.createElement('div');\n    this.node.classList.add(`query-field-portal-${props.index}`);\n    document.body.appendChild(this.node);\n  }\n\n  componentWillUnmount() {\n    document.body.removeChild(this.node);\n  }\n\n  render() {\n    return ReactDOM.createPortal(this.props.children, this.node);\n  }\n}\n\nclass QueryField extends React.Component<any, any> {\n  menuEl: any;\n  plugins: any;\n  resetTimer: any;\n\n  constructor(props, context) {\n    super(props, context);\n\n    this.plugins = [\n      BracesPlugin(),\n      ClearPlugin(),\n      RunnerPlugin({ handler: props.onPressEnter }),\n      NewlinePlugin(),\n      PluginPrism(),\n    ];\n\n    this.state = {\n      labelKeys: {},\n      labelValues: {},\n      metrics: props.metrics || [],\n      suggestions: [],\n      typeaheadIndex: 0,\n      typeaheadPrefix: '',\n      value: getInitialValue(props.initialQuery || ''),\n    };\n  }\n\n  componentDidMount() {\n    this.updateMenu();\n\n    if (this.props.metrics === undefined) {\n      this.fetchMetricNames();\n    }\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.resetTimer);\n  }\n\n  componentDidUpdate() {\n    this.updateMenu();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.metrics && nextProps.metrics !== this.props.metrics) {\n      this.setState({ metrics: nextProps.metrics }, this.onMetricsReceived);\n    }\n    // initialQuery is null in case the user typed\n    if (nextProps.initialQuery !== null && nextProps.initialQuery !== this.props.initialQuery) {\n      this.setState({ value: getInitialValue(nextProps.initialQuery) });\n    }\n  }\n\n  onChange = ({ value }) => {\n    const changed = value.document !== this.state.value.document;\n    this.setState({ value }, () => {\n      if (changed) {\n        this.handleChangeQuery();\n      }\n    });\n\n    window.requestAnimationFrame(this.handleTypeahead);\n  };\n\n  onMetricsReceived = () => {\n    if (!this.state.metrics) {\n      return;\n    }\n    configurePrismMetricsTokens(this.state.metrics);\n    // Trigger re-render\n    window.requestAnimationFrame(() => {\n      // Bogus edit to trigger highlighting\n      const change = this.state.value\n        .change()\n        .insertText(' ')\n        .deleteBackward(1);\n      this.onChange(change);\n    });\n  };\n\n  request = url => {\n    if (this.props.request) {\n      return this.props.request(url);\n    }\n    return fetch(url);\n  };\n\n  handleChangeQuery = () => {\n    // Send text change to parent\n    const { onQueryChange } = this.props;\n    if (onQueryChange) {\n      onQueryChange(Plain.serialize(this.state.value));\n    }\n  };\n\n  handleTypeahead = debounce(() => {\n    const selection = window.getSelection();\n    if (selection.anchorNode) {\n      const wrapperNode = selection.anchorNode.parentElement;\n      const editorNode = wrapperNode.closest('.query-field');\n      if (!editorNode || this.state.value.isBlurred) {\n        // Not inside this editor\n        return;\n      }\n\n      const range = selection.getRangeAt(0);\n      const text = selection.anchorNode.textContent;\n      const offset = range.startOffset;\n      const prefix = cleanText(text.substr(0, offset));\n\n      // Determine candidates by context\n      const suggestionGroups = [];\n      const wrapperClasses = wrapperNode.classList;\n      let typeaheadContext = null;\n\n      // Take first metric as lucky guess\n      const metricNode = editorNode.querySelector('.metric');\n\n      if (wrapperClasses.contains('context-range')) {\n        // Rate ranges\n        typeaheadContext = 'context-range';\n        suggestionGroups.push({\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        });\n      } else if (wrapperClasses.contains('context-labels') && metricNode) {\n        const metric = metricNode.textContent;\n        const labelKeys = this.state.labelKeys[metric];\n        if (labelKeys) {\n          if ((text && text.startsWith('=')) || wrapperClasses.contains('attr-value')) {\n            // Label values\n            const labelKeyNode = getPreviousCousin(wrapperNode, '.attr-name');\n            if (labelKeyNode) {\n              const labelKey = labelKeyNode.textContent;\n              const labelValues = this.state.labelValues[metric][labelKey];\n              typeaheadContext = 'context-label-values';\n              suggestionGroups.push({\n                label: 'Label values',\n                items: labelValues,\n              });\n            }\n          } else {\n            // Label keys\n            typeaheadContext = 'context-labels';\n            suggestionGroups.push({ label: 'Labels', items: labelKeys });\n          }\n        } else {\n          this.fetchMetricLabels(metric);\n        }\n      } else if (wrapperClasses.contains('context-labels') && !metricNode) {\n        // Empty name queries\n        const defaultKeys = ['job', 'instance'];\n        // Munge all keys that we have seen together\n        const labelKeys = Object.keys(this.state.labelKeys).reduce((acc, metric) => {\n          return acc.concat(this.state.labelKeys[metric].filter(key => acc.indexOf(key) === -1));\n        }, defaultKeys);\n        if ((text && text.startsWith('=')) || wrapperClasses.contains('attr-value')) {\n          // Label values\n          const labelKeyNode = getPreviousCousin(wrapperNode, '.attr-name');\n          if (labelKeyNode) {\n            const labelKey = labelKeyNode.textContent;\n            if (this.state.labelValues[EMPTY_METRIC]) {\n              const labelValues = this.state.labelValues[EMPTY_METRIC][labelKey];\n              typeaheadContext = 'context-label-values';\n              suggestionGroups.push({\n                label: 'Label values',\n                items: labelValues,\n              });\n            } else {\n              // Can only query label values for now (API to query keys is under development)\n              this.fetchLabelValues(labelKey);\n            }\n          }\n        } else {\n          // Label keys\n          typeaheadContext = 'context-labels';\n          suggestionGroups.push({ label: 'Labels', items: labelKeys });\n        }\n      } else if (metricNode && wrapperClasses.contains('context-aggregation')) {\n        typeaheadContext = 'context-aggregation';\n        const metric = metricNode.textContent;\n        const labelKeys = this.state.labelKeys[metric];\n        if (labelKeys) {\n          suggestionGroups.push({ label: 'Labels', items: labelKeys });\n        } else {\n          this.fetchMetricLabels(metric);\n        }\n      } else if (\n        (this.state.metrics && ((prefix && !wrapperClasses.contains('token')) || text.match(/[+\\-*/^%]/))) ||\n        wrapperClasses.contains('context-function')\n      ) {\n        // Need prefix for metrics\n        typeaheadContext = 'context-metrics';\n        suggestionGroups.push({\n          label: 'Metrics',\n          items: this.state.metrics,\n        });\n      }\n\n      let results = 0;\n      const filteredSuggestions = suggestionGroups.map(group => {\n        if (group.items) {\n          group.items = group.items.filter(c => c.length !== prefix.length && c.indexOf(prefix) > -1);\n          results += group.items.length;\n        }\n        return group;\n      });\n\n      console.log('handleTypeahead', selection.anchorNode, wrapperClasses, text, offset, prefix, typeaheadContext);\n\n      this.setState({\n        typeaheadPrefix: prefix,\n        typeaheadContext,\n        typeaheadText: text,\n        suggestions: results > 0 ? filteredSuggestions : [],\n      });\n    }\n  }, TYPEAHEAD_DEBOUNCE);\n\n  applyTypeahead(change, suggestion) {\n    const { typeaheadPrefix, typeaheadContext, typeaheadText } = this.state;\n\n    // Modify suggestion based on context\n    switch (typeaheadContext) {\n      case 'context-labels': {\n        const nextChar = getNextCharacter();\n        if (!nextChar || nextChar === '}' || nextChar === ',') {\n          suggestion += '=';\n        }\n        break;\n      }\n\n      case 'context-label-values': {\n        // Always add quotes and remove existing ones instead\n        if (!(typeaheadText.startsWith('=\"') || typeaheadText.startsWith('\"'))) {\n          suggestion = `\"${suggestion}`;\n        }\n        if (getNextCharacter() !== '\"') {\n          suggestion = `${suggestion}\"`;\n        }\n        break;\n      }\n\n      default:\n    }\n\n    this.resetTypeahead();\n\n    // Remove the current, incomplete text and replace it with the selected suggestion\n    let backward = typeaheadPrefix.length;\n    const text = cleanText(typeaheadText);\n    const suffixLength = text.length - typeaheadPrefix.length;\n    const offset = typeaheadText.indexOf(typeaheadPrefix);\n    const midWord = typeaheadPrefix && ((suffixLength > 0 && offset > -1) || suggestion === typeaheadText);\n    const forward = midWord ? suffixLength + offset : 0;\n\n    return (\n      change\n        // TODO this line breaks if cursor was moved left and length is longer than whole prefix\n        .deleteBackward(backward)\n        .deleteForward(forward)\n        .insertText(suggestion)\n        .focus()\n    );\n  }\n\n  onKeyDown = (event, change) => {\n    if (this.menuEl) {\n      const { typeaheadIndex, suggestions } = this.state;\n\n      switch (event.key) {\n        case 'Escape': {\n          if (this.menuEl) {\n            event.preventDefault();\n            this.resetTypeahead();\n            return true;\n          }\n          break;\n        }\n\n        case 'Tab': {\n          // Dont blur input\n          event.preventDefault();\n          if (!suggestions || suggestions.length === 0) {\n            return undefined;\n          }\n\n          // Get the currently selected suggestion\n          const flattenedSuggestions = flattenSuggestions(suggestions);\n          const selected = Math.abs(typeaheadIndex);\n          const selectedIndex = selected % flattenedSuggestions.length || 0;\n          const suggestion = flattenedSuggestions[selectedIndex];\n\n          this.applyTypeahead(change, suggestion);\n          return true;\n        }\n\n        case 'ArrowDown': {\n          // Select next suggestion\n          event.preventDefault();\n          this.setState({ typeaheadIndex: typeaheadIndex + 1 });\n          break;\n        }\n\n        case 'ArrowUp': {\n          // Select previous suggestion\n          event.preventDefault();\n          this.setState({ typeaheadIndex: Math.max(0, typeaheadIndex - 1) });\n          break;\n        }\n\n        default: {\n          // console.log('default key', event.key, event.which, event.charCode, event.locale, data.key);\n          break;\n        }\n      }\n    }\n    return undefined;\n  };\n\n  resetTypeahead = () => {\n    this.setState({\n      suggestions: [],\n      typeaheadIndex: 0,\n      typeaheadPrefix: '',\n      typeaheadContext: null,\n    });\n  };\n\n  async fetchLabelValues(key) {\n    const url = `/api/v1/label/${key}/values`;\n    try {\n      const res = await this.request(url);\n      const body = await (res.data || res.json());\n      const pairs = this.state.labelValues[EMPTY_METRIC];\n      const values = {\n        ...pairs,\n        [key]: body.data,\n      };\n      // const labelKeys = {\n      //   ...this.state.labelKeys,\n      //   [EMPTY_METRIC]: keys,\n      // };\n      const labelValues = {\n        ...this.state.labelValues,\n        [EMPTY_METRIC]: values,\n      };\n      this.setState({ labelValues }, this.handleTypeahead);\n    } catch (e) {\n      if (this.props.onRequestError) {\n        this.props.onRequestError(e);\n      } else {\n        console.error(e);\n      }\n    }\n  }\n\n  async fetchMetricLabels(name) {\n    const url = `/api/v1/series?match[]=${name}`;\n    try {\n      const res = await this.request(url);\n      const body = await (res.data || res.json());\n      const { keys, values } = processLabels(body.data);\n      const labelKeys = {\n        ...this.state.labelKeys,\n        [name]: keys,\n      };\n      const labelValues = {\n        ...this.state.labelValues,\n        [name]: values,\n      };\n      this.setState({ labelKeys, labelValues }, this.handleTypeahead);\n    } catch (e) {\n      if (this.props.onRequestError) {\n        this.props.onRequestError(e);\n      } else {\n        console.error(e);\n      }\n    }\n  }\n\n  async fetchMetricNames() {\n    const url = '/api/v1/label/__name__/values';\n    try {\n      const res = await this.request(url);\n      const body = await (res.data || res.json());\n      this.setState({ metrics: body.data }, this.onMetricsReceived);\n    } catch (error) {\n      if (this.props.onRequestError) {\n        this.props.onRequestError(error);\n      } else {\n        console.error(error);\n      }\n    }\n  }\n\n  handleBlur = () => {\n    const { onBlur } = this.props;\n    // If we dont wait here, menu clicks wont work because the menu\n    // will be gone.\n    this.resetTimer = setTimeout(this.resetTypeahead, 100);\n    if (onBlur) {\n      onBlur();\n    }\n  };\n\n  handleFocus = () => {\n    const { onFocus } = this.props;\n    if (onFocus) {\n      onFocus();\n    }\n  };\n\n  handleClickMenu = item => {\n    // Manually triggering change\n    const change = this.applyTypeahead(this.state.value.change(), item);\n    this.onChange(change);\n  };\n\n  updateMenu = () => {\n    const { suggestions } = this.state;\n    const menu = this.menuEl;\n    const selection = window.getSelection();\n    const node = selection.anchorNode;\n\n    // No menu, nothing to do\n    if (!menu) {\n      return;\n    }\n\n    // No suggestions or blur, remove menu\n    const hasSuggesstions = suggestions && suggestions.length > 0;\n    if (!hasSuggesstions) {\n      menu.removeAttribute('style');\n      return;\n    }\n\n    // Align menu overlay to editor node\n    if (node) {\n      const rect = node.parentElement.getBoundingClientRect();\n      menu.style.opacity = 1;\n      menu.style.top = `${rect.top + window.scrollY + rect.height + 4}px`;\n      menu.style.left = `${rect.left + window.scrollX - 2}px`;\n    }\n  };\n\n  menuRef = el => {\n    this.menuEl = el;\n  };\n\n  renderMenu = () => {\n    const { suggestions } = this.state;\n    const hasSuggesstions = suggestions && suggestions.length > 0;\n    if (!hasSuggesstions) {\n      return null;\n    }\n\n    // Guard selectedIndex to be within the length of the suggestions\n    let selectedIndex = Math.max(this.state.typeaheadIndex, 0);\n    const flattenedSuggestions = flattenSuggestions(suggestions);\n    selectedIndex = selectedIndex % flattenedSuggestions.length || 0;\n    const selectedKeys = flattenedSuggestions.length > 0 ? [flattenedSuggestions[selectedIndex]] : [];\n\n    // Create typeahead in DOM root so we can later position it absolutely\n    return (\n      <Portal>\n        <Typeahead\n          menuRef={this.menuRef}\n          selectedItems={selectedKeys}\n          onClickItem={this.handleClickMenu}\n          groupedItems={suggestions}\n        />\n      </Portal>\n    );\n  };\n\n  render() {\n    return (\n      <div className=\"query-field\">\n        {this.renderMenu()}\n        <Editor\n          autoCorrect={false}\n          onBlur={this.handleBlur}\n          onKeyDown={this.onKeyDown}\n          onChange={this.onChange}\n          onFocus={this.handleFocus}\n          placeholder={this.props.placeholder}\n          plugins={this.plugins}\n          spellCheck={false}\n          value={this.state.value}\n        />\n      </div>\n    );\n  }\n}\n\nexport default QueryField;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/QueryField.tsx","// Node.closest() polyfill\nif ('Element' in window && !Element.prototype.closest) {\n  Element.prototype.closest = function(s) {\n    const matches = (this.document || this.ownerDocument).querySelectorAll(s);\n    let el = this;\n    let i;\n    // eslint-disable-next-line\n    do {\n      i = matches.length;\n      // eslint-disable-next-line\n      while (--i >= 0 && matches.item(i) !== el) {}\n    } while (i < 0 && (el = el.parentElement));\n    return el;\n  };\n}\n\nexport function getPreviousCousin(node, selector) {\n  let sibling = node.parentElement.previousSibling;\n  let el;\n  while (sibling) {\n    el = sibling.querySelector(selector);\n    if (el) {\n      return el;\n    }\n    sibling = sibling.previousSibling;\n  }\n  return undefined;\n}\n\nexport function getNextCharacter(global = window) {\n  const selection = global.getSelection();\n  if (!selection.anchorNode) {\n    return null;\n  }\n\n  const range = selection.getRangeAt(0);\n  const text = selection.anchorNode.textContent;\n  const offset = range.startOffset;\n  return text.substr(offset, 1);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/utils/dom.ts","const BRACES = {\n  '[': ']',\n  '{': '}',\n  '(': ')',\n};\n\nexport default function BracesPlugin() {\n  return {\n    onKeyDown(event, change) {\n      const { value } = change;\n      if (!value.isCollapsed) {\n        return undefined;\n      }\n\n      switch (event.key) {\n        case '{':\n        case '[': {\n          event.preventDefault();\n          // Insert matching braces\n          change\n            .insertText(`${event.key}${BRACES[event.key]}`)\n            .move(-1)\n            .focus();\n          return true;\n        }\n\n        case '(': {\n          event.preventDefault();\n          const text = value.anchorText.text;\n          const offset = value.anchorOffset;\n          const space = text.indexOf(' ', offset);\n          const length = space > 0 ? space : text.length;\n          const forward = length - offset;\n          // Insert matching braces\n          change\n            .insertText(event.key)\n            .move(forward)\n            .insertText(BRACES[event.key])\n            .move(-1 - forward)\n            .focus();\n          return true;\n        }\n\n        default: {\n          break;\n        }\n      }\n      return undefined;\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/slate-plugins/braces.ts","// Clears the rest of the line after the caret\nexport default function ClearPlugin() {\n  return {\n    onKeyDown(event, change) {\n      const { value } = change;\n      if (!value.isCollapsed) {\n        return undefined;\n      }\n\n      if (event.key === 'k' && event.ctrlKey) {\n        event.preventDefault();\n        const text = value.anchorText.text;\n        const offset = value.anchorOffset;\n        const length = text.length;\n        const forward = length - offset;\n        change.deleteForward(forward);\n        return true;\n      }\n      return undefined;\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/slate-plugins/clear.ts","function getIndent(text) {\n  let offset = text.length - text.trimLeft().length;\n  if (offset) {\n    let indent = text[0];\n    while (--offset) {\n      indent += text[0];\n    }\n    return indent;\n  }\n  return '';\n}\n\nexport default function NewlinePlugin() {\n  return {\n    onKeyDown(event, change) {\n      const { value } = change;\n      if (!value.isCollapsed) {\n        return undefined;\n      }\n\n      if (event.key === 'Enter' && event.shiftKey) {\n        event.preventDefault();\n\n        const { startBlock } = value;\n        const currentLineText = startBlock.text;\n        const indent = getIndent(currentLineText);\n\n        return change\n          .splitBlock()\n          .insertText(indent)\n          .focus();\n      }\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/slate-plugins/newline.ts","import React from 'react';\nimport Prism from 'prismjs';\n\nimport Promql from './promql';\n\nPrism.languages.promql = Promql;\n\nconst TOKEN_MARK = 'prism-token';\n\nexport function configurePrismMetricsTokens(metrics) {\n  Prism.languages.promql.metric = {\n    alias: 'variable',\n    pattern: new RegExp(`(?:^|\\\\s)(${metrics.join('|')})(?:$|\\\\s)`),\n  };\n}\n\n/**\n * Code-highlighting plugin based on Prism and\n * https://github.com/ianstormtaylor/slate/blob/master/examples/code-highlighting/index.js\n *\n * (Adapted to handle nested grammar definitions.)\n */\n\nexport default function PrismPlugin() {\n  return {\n    /**\n     * Render a Slate mark with appropiate CSS class names\n     *\n     * @param {Object} props\n     * @return {Element}\n     */\n\n    renderMark(props) {\n      const { children, mark } = props;\n      // Only apply spans to marks identified by this plugin\n      if (mark.type !== TOKEN_MARK) {\n        return undefined;\n      }\n      const className = `token ${mark.data.get('types')}`;\n      return <span className={className}>{children}</span>;\n    },\n\n    /**\n     * Decorate code blocks with Prism.js highlighting.\n     *\n     * @param {Node} node\n     * @return {Array}\n     */\n\n    decorateNode(node) {\n      if (node.type !== 'paragraph') {\n        return [];\n      }\n\n      const texts = node.getTexts().toArray();\n      const tstring = texts.map(t => t.text).join('\\n');\n      const grammar = Prism.languages.promql;\n      const tokens = Prism.tokenize(tstring, grammar);\n      const decorations = [];\n      let startText = texts.shift();\n      let endText = startText;\n      let startOffset = 0;\n      let endOffset = 0;\n      let start = 0;\n\n      function processToken(token, acc?) {\n        // Accumulate token types down the tree\n        const types = `${acc || ''} ${token.type || ''} ${token.alias || ''}`;\n\n        // Add mark for token node\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          startText = endText;\n          startOffset = endOffset;\n\n          const content = typeof token === 'string' ? token : token.content;\n          const newlines = content.split('\\n').length - 1;\n          const length = content.length - newlines;\n          const end = start + length;\n\n          let available = startText.text.length - startOffset;\n          let remaining = length;\n\n          endOffset = startOffset + remaining;\n\n          while (available < remaining) {\n            endText = texts.shift();\n            remaining = length - available;\n            available = endText.text.length;\n            endOffset = remaining;\n          }\n\n          // Inject marks from up the tree (acc) as well\n          if (typeof token !== 'string' || acc) {\n            const range = {\n              anchorKey: startText.key,\n              anchorOffset: startOffset,\n              focusKey: endText.key,\n              focusOffset: endOffset,\n              marks: [{ type: TOKEN_MARK, data: { types } }],\n            };\n\n            decorations.push(range);\n          }\n\n          start = end;\n        } else if (token.content && token.content.length) {\n          // Tokens can be nested\n          for (const subToken of token.content) {\n            processToken(subToken, types);\n          }\n        }\n      }\n\n      // Process top-level tokens\n      for (const token of tokens) {\n        processToken(token);\n      }\n\n      return decorations;\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/slate-plugins/prism/index.tsx","export const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];\n\nconst AGGREGATION_OPERATORS = [\n  'sum',\n  'min',\n  'max',\n  'avg',\n  'stddev',\n  'stdvar',\n  'count',\n  'count_values',\n  'bottomk',\n  'topk',\n  'quantile',\n];\n\nexport const FUNCTIONS = [\n  ...AGGREGATION_OPERATORS,\n  'abs',\n  'absent',\n  'ceil',\n  'changes',\n  'clamp_max',\n  'clamp_min',\n  'count_scalar',\n  'day_of_month',\n  'day_of_week',\n  'days_in_month',\n  'delta',\n  'deriv',\n  'drop_common_labels',\n  'exp',\n  'floor',\n  'histogram_quantile',\n  'holt_winters',\n  'hour',\n  'idelta',\n  'increase',\n  'irate',\n  'label_replace',\n  'ln',\n  'log2',\n  'log10',\n  'minute',\n  'month',\n  'predict_linear',\n  'rate',\n  'resets',\n  'round',\n  'scalar',\n  'sort',\n  'sort_desc',\n  'sqrt',\n  'time',\n  'vector',\n  'year',\n  'avg_over_time',\n  'min_over_time',\n  'max_over_time',\n  'sum_over_time',\n  'count_over_time',\n  'quantile_over_time',\n  'stddev_over_time',\n  'stdvar_over_time',\n];\n\nconst tokenizer = {\n  comment: {\n    pattern: /(^|[^\\n])#.*/,\n    lookbehind: true,\n  },\n  'context-aggregation': {\n    pattern: /((by|without)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^,\\s][^,]*[^,\\s]*/,\n        alias: 'attr-name',\n      },\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=})/,\n    inside: {\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/[-+*/=%^~]|&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\\\b(?:${OPERATORS.join('|')})\\\\b`, 'i'),\n  punctuation: /[{};()`,.]/,\n};\n\nexport default tokenizer;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/slate-plugins/prism/promql.ts","export default function RunnerPlugin({ handler }) {\n  return {\n    onKeyDown(event) {\n      // Handle enter\n      if (handler && event.key === 'Enter' && !event.shiftKey) {\n        // Submit on Enter\n        event.preventDefault();\n        handler(event);\n        return true;\n      }\n      return undefined;\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/slate-plugins/runner.ts","// Based on underscore.js debounce()\nexport default function debounce(func, wait) {\n  let timeout;\n  return function() {\n    const context = this;\n    const args = arguments;\n    const later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/utils/debounce.ts","export const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\n\nexport function processLabels(labels) {\n  const values = {};\n  labels.forEach(l => {\n    const { __name__, ...rest } = l;\n    Object.keys(rest).forEach(key => {\n      if (!values[key]) {\n        values[key] = [];\n      }\n      if (values[key].indexOf(rest[key]) === -1) {\n        values[key].push(rest[key]);\n      }\n    });\n  });\n  return { values, keys: Object.keys(values) };\n}\n\n// Strip syntax chars\nexport const cleanText = s => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/utils/prometheus.ts","import React from 'react';\n\nfunction scrollIntoView(el) {\n  if (!el || !el.offsetParent) {\n    return;\n  }\n  const container = el.offsetParent;\n  if (el.offsetTop > container.scrollTop + container.offsetHeight || el.offsetTop < container.scrollTop) {\n    container.scrollTop = el.offsetTop - container.offsetTop;\n  }\n}\n\nclass TypeaheadItem extends React.PureComponent<any, any> {\n  el: any;\n  componentDidUpdate(prevProps) {\n    if (this.props.isSelected && !prevProps.isSelected) {\n      scrollIntoView(this.el);\n    }\n  }\n\n  getRef = el => {\n    this.el = el;\n  };\n\n  render() {\n    const { isSelected, label, onClickItem } = this.props;\n    const className = isSelected ? 'typeahead-item typeahead-item__selected' : 'typeahead-item';\n    const onClick = () => onClickItem(label);\n    return (\n      <li ref={this.getRef} className={className} onClick={onClick}>\n        {label}\n      </li>\n    );\n  }\n}\n\nclass TypeaheadGroup extends React.PureComponent<any, any> {\n  render() {\n    const { items, label, selected, onClickItem } = this.props;\n    return (\n      <li className=\"typeahead-group\">\n        <div className=\"typeahead-group__title\">{label}</div>\n        <ul className=\"typeahead-group__list\">\n          {items.map(item => (\n            <TypeaheadItem key={item} onClickItem={onClickItem} isSelected={selected.indexOf(item) > -1} label={item} />\n          ))}\n        </ul>\n      </li>\n    );\n  }\n}\n\nclass Typeahead extends React.PureComponent<any, any> {\n  render() {\n    const { groupedItems, menuRef, selectedItems, onClickItem } = this.props;\n    return (\n      <ul className=\"typeahead\" ref={menuRef}>\n        {groupedItems.map(g => (\n          <TypeaheadGroup key={g.label} onClickItem={onClickItem} selected={selectedItems} {...g} />\n        ))}\n      </ul>\n    );\n  }\n}\n\nexport default Typeahead;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/Typeahead.tsx","import $ from 'jquery';\nimport React, { Component } from 'react';\n\nimport TimeSeries from 'app/core/time_series2';\n\nimport 'vendor/flot/jquery.flot';\nimport 'vendor/flot/jquery.flot.time';\n\n// Copied from graph.ts\nfunction time_format(ticks, min, max) {\n  if (min && max && ticks) {\n    var range = max - min;\n    var secPerTick = range / ticks / 1000;\n    var oneDay = 86400000;\n    var oneYear = 31536000000;\n\n    if (secPerTick <= 45) {\n      return '%H:%M:%S';\n    }\n    if (secPerTick <= 7200 || range <= oneDay) {\n      return '%H:%M';\n    }\n    if (secPerTick <= 80000) {\n      return '%m/%d %H:%M';\n    }\n    if (secPerTick <= 2419200 || range <= oneYear) {\n      return '%m/%d';\n    }\n    return '%Y-%m';\n  }\n\n  return '%H:%M';\n}\n\nconst FLOT_OPTIONS = {\n  legend: {\n    show: false,\n  },\n  series: {\n    lines: {\n      linewidth: 1,\n      zero: false,\n    },\n    shadowSize: 0,\n  },\n  grid: {\n    minBorderMargin: 0,\n    markings: [],\n    backgroundColor: null,\n    borderWidth: 0,\n    // hoverable: true,\n    clickable: true,\n    color: '#a1a1a1',\n    margin: { left: 0, right: 0 },\n    labelMarginX: 0,\n  },\n  // selection: {\n  //   mode: 'x',\n  //   color: '#666',\n  // },\n  // crosshair: {\n  //   mode: 'x',\n  // },\n};\n\nclass Graph extends Component<any, any> {\n  componentDidMount() {\n    this.draw();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (\n      prevProps.data !== this.props.data ||\n      prevProps.options !== this.props.options ||\n      prevProps.height !== this.props.height\n    ) {\n      this.draw();\n    }\n  }\n\n  draw() {\n    const { data, options: userOptions } = this.props;\n    if (!data) {\n      return;\n    }\n    const series = data.map((ts: TimeSeries) => ({\n      label: ts.label,\n      data: ts.getFlotPairs('null'),\n    }));\n\n    const $el = $(`#${this.props.id}`);\n    const ticks = $el.width() / 100;\n    const min = userOptions.range.from.valueOf();\n    const max = userOptions.range.to.valueOf();\n    const dynamicOptions = {\n      xaxis: {\n        mode: 'time',\n        min: min,\n        max: max,\n        label: 'Datetime',\n        ticks: ticks,\n        timeformat: time_format(ticks, min, max),\n      },\n    };\n    const options = {\n      ...FLOT_OPTIONS,\n      ...dynamicOptions,\n      ...userOptions,\n    };\n    $.plot($el, series, options);\n  }\n\n  render() {\n    const style = {\n      height: this.props.height || '400px',\n      width: this.props.width || '100%',\n    };\n\n    return <div id={this.props.id} style={style} />;\n  }\n}\n\nexport default Graph;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/Graph.tsx","import React, { PureComponent } from 'react';\n// import TableModel from 'app/core/table_model';\n\nconst EMPTY_TABLE = {\n  columns: [],\n  rows: [],\n};\n\nexport default class Table extends PureComponent<any, any> {\n  render() {\n    const { className = '', data } = this.props;\n    const tableModel = data || EMPTY_TABLE;\n    return (\n      <table className={`${className} filter-table`}>\n        <thead>\n          <tr>{tableModel.columns.map(col => <th key={col.text}>{col.text}</th>)}</tr>\n        </thead>\n        <tbody>\n          {tableModel.rows.map((row, i) => <tr key={i}>{row.map((content, j) => <td key={j}>{content}</td>)}</tr>)}\n        </tbody>\n      </table>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/Table.tsx","export function buildQueryOptions({ format, interval, instant, now, queries }) {\n  const to = now;\n  const from = to - 1000 * 60 * 60 * 3;\n  return {\n    interval,\n    range: {\n      from,\n      to,\n    },\n    targets: queries.map(expr => ({\n      expr,\n      format,\n      instant,\n    })),\n  };\n}\n\nexport function generateQueryKey(index = 0) {\n  return `Q-${Date.now()}-${Math.random()}-${index}`;\n}\n\nexport function ensureQueries(queries?) {\n  if (queries && typeof queries === 'object' && queries.length > 0 && typeof queries[0] === 'string') {\n    return queries.map((query, i) => ({ key: generateQueryKey(i), query }));\n  }\n  return [{ key: generateQueryKey(), query: '' }];\n}\n\nexport function hasQuery(queries) {\n  return queries.some(q => q.query);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--2!./public/app/containers/Explore/utils/query.ts"],"sourceRoot":""}